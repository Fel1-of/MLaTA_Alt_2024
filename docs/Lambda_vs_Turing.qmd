## Различия между Lambda и Turing

По сути, они обе полны по Тьюрингу, одно можно заменить другим.

Разница представлена в виде таблицы:

| Критерий | Lambda | Turing |
|------------------------|------------------------|------------------------|
| Модель | Абстрактная математическая модель, основанная на функциях и их применении. | Абстрактный автомат с лентой и таблицей переходов. |
| Форма | Вычисления задаются через функциональные преобразования и рекурсию. | Операции определяются через пошаговые модификации ленты и состояния. |
| Декларативность | Больше ориентировано на выражение функций. | Инструкции описывают шаги выполнения. |
| Абстракция | Высокий уровень абстракции. Математическая чистота. | Более низкий уровень, приближённый к реальному исполнению на машине. |
| Выражение алгоритмов | Композиция функций. | Состояния и пошаговое изменение ленты. |
| Читаемость | Более сложное для восприятия новичками из-за чисто функционального подхода. | Более наглядное для имитации конкретного вычислительного процесса. |

## Плюсы и минусы

### Labmda

Плюсы: - Высокий уровень абстракции: позволяет описывать вычисления чисто математически. - Функциональный стиль: компактное и декларативное представление программ. - Математическая чистота: формальные доказательства корректности функций проще проводить. - Близость к современным языкам программирования: многие языки (например, Haskell, Lisp) используют идеи лямбда-исчисления.

Минусы: - Трудности интерпретации: выполнение требует преобразования функций, что сложно для понимания. - Ограниченность моделирования состояния: отсутствие "пошагового" изменения состояния, как в императивных моделях. - Сложность реализации: для реального железа необходимо трансформировать выражения в машинные инструкции.

### Turing

Плюсы: - Наглядность и интуитивность: легко представить вычисление как последовательность шагов. - Приближенность к аппаратному исполнению: модели состояния близки к работе процессоров. - Гибкость моделирования: можно выразить любые алгоритмы с дискретным изменением памяти. - Основа императивного программирования: родоначальник современных языков и архитектуры компьютеров.

Минусы: - Низкий уровень абстракции: описания вычислений могут быть громоздкими. - Медлительность: моделирование сложных алгоритмов требует большого количества шагов. - Неудобство для функционального стиля: для чисто математических выражений менее эффективен.

## Что лучше делать на каждом?

### Lambda

-   Функциональное программирование: когда нужно выразить вычисления через композицию функций (например, рекурсивные алгоритмы).
-   Доказательства корректности алгоритмов: благодаря чисто математическому подходу.
-   Разработка теоретических моделей вычислений: например, исследование вычислимости функций или формального анализа программ.
-   Комбинаторные вычисления: системы, использующие функции высшего порядка.

### Turing

-   Моделирование пошаговых вычислений: например, алгоритмы работы памяти или устройства.
-   Императивные алгоритмы: программы, работающие со состоянием и изменяющие память (циклы, присваивания).
-   Создание симуляторов реального оборудования: имитация работы процессоров, интерпретаторов.
-   Теоретические исследования конечных автоматов и их расширений.

## Пример алгоритма сложения

### lambda

```         
add = λm.λn.λf.λx. m f (n f x)

add 2 3
= (λm.λn.λf.λx. m f (n f x)) 2 3

add 2 3 = λf.λx. (λf.λx.f (f x)) f ((λf.λx.f (f (f x))) f x)
```

### Turing

```         
q0 1 > q0 1 R
q0 # > q1 # R
q1 1 > q2 E L
q 2 1 > q2 1 L
q2 # > q0 # R
q0 E > qf E Stop

111#11 > 11111
```