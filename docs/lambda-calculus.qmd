# Нетипизированное лямбда-исчисление

## Определение

``` text
t ::=
    x  # переменная (variable)
    | λx.t  # абстракция (lambda abstraction)
    | t t  # применение (application)
```

------------------------------------------------------------------------

## Соглашения

1.  Лево-ассоциативность применения:

``` text
t1 t2 t3 = (t1 t2) t3
```

2.  Тело абстракции идёт до конца выражения:

``` text
λx.λy.x y = λx.(λy.(x y))

λx.λy.x y z = λx.(λy.((x y) z))
```

------------------------------------------------------------------------

## Область видимости

1.  Переменные связываются абстракциями:

``` text
λx.t
# Если `x` входит в `t`,
# то `x` связан (bound) абстракцией
# `λx` — связывающие определение (binder)
#  с областью видимости `t`
```

```         
x y # `x` свободен
λy.x y # `x` свободен

λx.x # `x` связан
λz.λx.λy.x (y z) # `x` связан

(λx.x) x # Первый `x` связан, второй свободен
```

------------------------------------------------------------------------

## Замкнутый терм. Комбинатор

Замкнутый (closed) терм — терм без свободных переменных

``` text
λx.x # Комбинатор тождества
id = λx.x
```

------------------------------------------------------------------------

## Бета-редукция

``` text
(λx.t) u → t[x := u]
```

`t[x := u]` — терм `t`, в котором все свободные вхождения `x` заменены на `u`

------------------------------------------------------------------------

## Примеры

1.  Применение комбинатора тождества к переменной:

``` text
(λx.x) y → x[x := y] = y
```

2.  Применение комбинатора тождества к комбинатору тождества:

``` text
(λx.x) (λx.x) → x[x := (λx.x)] = λx.x
```

3.  Лево-ассоциативность

``` text
(λx.x) (λx.x) y → x[x := (λx.x)] y = λx.x y
```

------------------------------------------------------------------------

## Стратегии редукции

<!-- TODO: Надо поменять пример на нормальный при котором видна разница -->

### Полная бета-редукция

Выбор следующего редекса не зависит от порядка

``` text
(λx.x) ((λx.x) (λz.(λx.x) z))
→ (λx.x) ((λx.x) (λz.z))
→ (λx.x) (λz.z)
→ λz.z
```

### Нормальный порядок

Всегда редуцируется самый левый внешний редекс

``` text
(λx.x) ((λx.x) (λz.(λx.x) z))
→ (λx.x) (λz.(λx.x) z)
→ λz.(λx.x) z
→ λz.z
```

### Вызов по имени

Всегда редуцируется самый левый внешний редекс, который не содержит абстракций

``` text
(λx.x) ((λx.x) (λz.(λx.x) z))
→ (λx.x) (λz.(λx.x) z)
→ λz.(λx.x) z  # Не редуцируется
```

### Вызов по значению

Всегда редуцируется самый левый внешний редекс, который не содержит абстракций и не является переменной

``` text
(λx.x) ((λx.x) (λz.(λx.x) z))
→ (λx.x) (λz.(λx.x) z)
→ λz.(λx.x) z  # Не редуцируется
```

## Функции нескольких аргументов

Их нет, но есть есть функции высшего порядка

``` text
f = λ(x, y).s  # Такого терма нет
f = λx.λy.s  # Вместо этого используется каррирование
f v w = (f v) w → ((λx.λy.s) v) w → (λy.s[x := v]) w → s[x := v][y := w]
```

------------------------------------------------------------------------

## Подстановка

``` text
x[x := u] = u
y[x := u] = y
(λy.t)[x := u] = λy.t[x := u]
(t1 t2)[x := u] = t1[x := u] t2[x := u]
```

``` text
(λx.x)[x := u] != λx.u # x связан
(λx.x)[x := u] = λx.x # подстановка должна заканчиваться на связанной переменной
```

``` text
(λx.y)[y := x] = λx.x # y свободен
# x при подстановке тоже не связан
# но в результате подстановки мы получили
# связанную переменную — захватили свободную переменную
```

### Альфа-конверсия

``` text
(λx.s) = (λy.s[x := y])
```

### Подстановка. Окончательное определение

``` text
x[x := u] = u
y[x := u] = y # если `y` != `x`
(λy.t)[x := u] = λy.t[x := u] # если `y` != `x` и `y` не свободен в `u`
(t1 t2)[x := u] = t1[x := u] t2[x := u]
```