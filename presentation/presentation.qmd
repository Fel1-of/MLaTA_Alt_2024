---
title: "λ-исчисление"
author:
  - name: Рыжиков И.С.
    email: iwanryzij@yandex.ru
  - name: Комосский Е.А.
description: "Презентация по λ-исчислению"
format: 
  revealjs:
    slide-number: true
    chalkboard: true
    transition: slide
editor: visual
jupyter: python3
---

## История появления

1.  Фреге 1893

$$A + B = (\oplus(A))(B)$$

2.  Рассел 1910. Теория типов

3.  Шейнфинкель 1924

4.  Чёрчь 1932

$$
λx.M
$$


## Зачем придумана теория типов

- В наивной теории множеств существует парадокс Рассела
- Типы создают иерархию объектов, исключая самоссылку
- Ограничение допустимых формул



## Определение λ-исчисления. Термы

``` css
t ::=
    x  # переменная (variable)
    | λx.t  # абстракция (lambda abstraction)
    | t t  # применение (application)
```

::: {.fragment}
**Примеры**

``` text
x
λx.t
t t
λx.(λy.(x y))
(λx.(λy.(x y))) z
((λx.(λy.(x y))) z) w
```
:::

## Соглашения

1.  Лево-ассоциативность применения:

``` text
t1 t2 t3 = (t1 t2) t3
```

2.  Тело абстракции идёт до конца выражения:

``` css
λx. x y = λx. (x y)

λx.λy.x y = λx.(λy.(x y))

λx.λy.x y z = λx.(λy.((x y) z))

(λx. λy. x y) z w = ((λx.(λy.(x y))) z) w
```


## Примеры

::: {.fragment}

1.  Комбинатор тождества

```css
(λx.x) y 
→ x[x := y] 
= y
```

:::

::: {.fragment}


2. Применение комбинатора тождества к комбинатору тождества

``` css
(λx.x) (λx.x) → 
x[x := (λx.x)] 
= λx.x
```
:::

::: {.fragment}

3.  Лево-ассоциативность

``` css
(λx.x) (λx.x) y 
→ x[x := (λx.x)] y 
= λx.x y
```

:::

## Формализация. $\beta$-редукция

```{.css}
(λx.t) u → t[x := u]

```

Заменяем в терме $t$ вхождения $x$ на $u$ и убираем λ, то есть _редуцируем_.

::: {.fragment}
__$\beta$-редукция — вычисление в λ-исчислении__
:::

## true, false, if

Введем константы

```{.css}
tru = λt. λf. t # возвращает первый аргумент
fls = λt. λf. f # возвращает второй аргумент
```

Введем функцию test — аналог if-else

```{.css}
test = λl. λm. λn. l m n
```

::: {.fragment}

Пример

```{.css code-line-numbers="|1|2|3|4|5|6|7|8"}
test tru v w = 
= (λl. λm. λn. l m n) tru v w →
→ (λm. λn. tru m n) v w →
→ (λn. tru v n) w →
→ tru v w =
= (λt. λf. t) v w →
→ (λf. v) w →
→ v
```

:::
## Бесконечная саморедукция

Рассмотрим следующую функцию $\omega = λx.x\ x$.
Применим её к самой себе:

```{.css code-line-numbers="|1|3|3-4|3-5"}
w y = (λx.x x) y → y y

w w = (λx.x x) (λx.x x) →
→ (λx.x x) (λx.x x) →
...
```

## Подстановка

```{.css}
x[x := u] = u
y[x := u] = y
(λy.t)[x := u] = λy.t[x := u]
(t1 t2)[x := u] = t1[x := u] t2[x := u]
```

::: {.fragment}
λ связывает переменные

```{.css}
(λx.x)[x := u] != λx.u  # x связан
(λx.x)[x := u] = λx.x   # подстановка должна заканчиваться на связанной переменной
```

:::

::: {.fragment}
НО

```{.css}
(λx.y)[y := x] = λx.x # y свободен — x при подстановке должен остаться не связанным,
# но в результате подстановки мы получили
# связанную переменную — захватили свободную переменную
```
:::

##  Решение. $\alpha$-конверсия

```text
(λx.s) = (λy.s[x := y])
```

## Сравнение с языками программирования

λ-исчисление
```{.css}
λx.λy.(x + y)
```

Python

```{.python}
add = lambda x: lambda y: x + y
```

JS

```{.js}
const add = x => y => x + y;
```

Haskell

```{.haskell}
add :: Int -> Int -> Int
add x y = x + y
-- или
add = \x -> \y -> x + y
```

## Типы {.smaller}

Введем множество типов переменных $\mathcal{X}$. И населим его одним базовым типом $\circ$

$$
\mathcal{X} = \{\circ\}
$$

Тип переменной $x$ обозначается $x:\alpha$
$$
\begin{align}
& x:\circ \\
& y:\circ \\
\end{align}
$$

Тип функции $f$ обозначается $f:\alpha → \beta$
$$
\begin{align}
& f = λx^\circ .y \\
& f:{\circ→\circ}
\end{align}
$$

## Типизация по Черчу

- Каждая константа имеет свой тип
- В каждом типе есть свой счетный набор переменных

:::{.fragment}
$$
\begin{align}
& u:\beta  \text{ переменная } u \text{ имеет жестко заданный тип } \beta \\
\end{align}
$$
:::

:::{.fragment}
$$
\begin{align}
& u:\beta \implies (λx^\sigma.u) : (\sigma → \beta) \\
\end{align}
$$
:::

:::{.fragment}
$$
\begin{align}
& u:(\alpha → \beta),\ v:\alpha  \implies u\ v : \beta
\end{align}
$$
:::

## Типизация по Карри

- Термы остаются такие же как и в бестиповом
- Вводится отношение типизируемости
- Для свободных переменных типы задаются явно
- Остальные типы выводятся

## Типизация по Карри

$\Gamma \vdash u:b$

Если из контекста имеется вывод, что $u:b$ тогда $u$ может иметь тип $b$

::: {.fragment}
$\Gamma, x:\alpha \vdash x : \alpha$
:::

::: {.fragment}
$\Gamma \vdash u: (\alpha → \beta),\ \Gamma \vdash v : \alpha \implies \Gamma \vdash (uv) : \beta$
:::

::: {.fragment}
$\Gamma, x : \alpha \vdash u : \beta \implies \Gamma \vdash (λx. u) : (\alpha → \beta)$
:::

## Типы. Bool и Nat

$$
\begin{align}
& true = λt^\circ. λf^\circ. t \\
& false = λt^\circ. λf^\circ. f \\
& Bool = \circ → \circ → \circ\ \\
\\
& zero = λs^{\circ→\circ}. λz^\circ. z\\
& succ = λn. λs. λz^\circ. s\ n\ s\ z \\
& one = succ\ zero = λs. λz^\circ. s\ z\\
& ... \\
& Nat = (\circ → \circ) → \circ → \circ
\end{align}
$$

## Коротко

_Типизация по Черчу_

- Переопределяются термы
- Всё имеет заданный жесткий тип

_Типизация по Карри_

- Термы такие же как в бестиповом
- Типы выводятся
- Для некоторых термов может не существовать типа

## Выгода типизации

- Запрет конструкций `(λx.x x) (λx.x x)`, т.к. она не имеет типа.
- Статический контроль. $\beta$-редукция сохраняет тип выражения

:::{.notes}
λx.x x — не имеет типа
:::


## Тьюринг vs Lambda

_λ-исчисление_

- Ориентирован на математические функции
- Композиция функций
- Высокая абстракция

_Машина Тьюринга_

- Автомат с лентой таблицей переходов
- Дискретные состояния и пошаговое изменение ленты
- Явное представление

## Сложение чисел

λ-исчисление

```{.css}
2 = λs λz s (s z)
3 = λs λz s (s (s z))
add = λm. λn. λs. λz. m s (n s z)

add 2 3
```

Машина Тьюринга

```{.css}
q0 1 → q0 1 R
q0 # → q0 # R
q1 1 → q2 ε L
q2 1 → q2 1 L
q2 # → q0 1 R
q0 ε → q0 ε N

111#11 > 11111
```

## Спасибо за внимание! {.center style="text-align: center;"}
