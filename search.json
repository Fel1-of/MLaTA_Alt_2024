[
  {
    "objectID": "docs/History.html",
    "href": "docs/History.html",
    "title": "λ-исчисление",
    "section": "",
    "text": "Фундаментализация математики\nВ начале XX века математики (особенно Давид Гильберт и его последователи) стремились создать строгую формальную основу для всей математики. Важную роль в этом поиске играло формализованное описание функций и самого понятия «вычисления».\nЛогические парадоксы\nВозникновение парадоксов в теории множеств (парадокс Рассела, парадокс Бурали-Форти) поставило под сомнение классические подходы к обоснованию математики и подтолкнуло учёных искать более безопасные формальные системы, свободные от противоречий.\n\n\n\n\n\n\nПервоначальные публикации\nС 1932 по 1936 год Алонзо Чёрч опубликовал ряд статей, посвящённых формализации понятия «вычислимая функция». Он представил идею лямбда-исчисления, в котором любая функция задаётся путём лямбда-абстракции и аппликации (применения к аргументам).\nСистема символического манипулирования\nЛямбда-исчисление Чёрча было задумано как способ манипулировать функциями в чисто символическом виде. В нём можно выражать и комбинировать функции, не ссылаясь на их «внутреннее строение».\nСтивен Клини и Джон Россер\nПод руководством Чёрча работала группа математиков, среди них — Клини и Россер, которые помогали развивать и уточнять основы лямбда-исчисления и расширяли теорию рекурсивных функций.\n\n\n\n\n\n\nРаботы Алана Тьюринга\nВ 1936 году Алан Тьюринг представил абстрактную машину (машину Тьюринга), призванную формализовать понятие алгоритма. Тьюринг доказал, что класс функций, вычислимых на машине Тьюринга, совпадает с классом функций, которые можно определить в лямбда-исчислении.\nТезис Чёрча — Тьюринга\nНа основе этих результатов сформировался тезис (не имеющий строгого доказательства, но общепризнанный), согласно которому все «разумные» модели вычислений (машины Тьюринга, лямбда-исчисление, рекурсивные функции) обладают одинаковой вычислительной мощностью.\n\n\n\n\n\n\nПроблема парадоксов\nУже в 1930-е годы стало ясно, что «чистое» лямбда-исчисление может приводить к логическим парадоксам (например, парадоксу Клини – Россера), если рассматривать его как базис для формальной логики без дополнительных ограничений.\nВведение типов (Simply Typed Lambda Calculus)\nПервым, кто предложил теорию, свободную от парадокса Рассела, был сам Рассел. Он разработал теорию типов. В основе этой теории лежит следующая идея: простые объекты в этой теории имеют тип 0, множества простых объектов имеют тип 1, множества множеств простых объектов имеют тип 2 и так далее. Таким образом, ни одно множество не может иметь себя в качестве элемента. В ней были свои проблемы, поэтому распространения она не получила.\nЧтобы избежать этих парадоксов, Алонзо Чёрч в 1940 году предложил типизированную версию лямбда-исчисления (так называемый Simply Typed Lambda Calculus). В этой системе каждой лямбда-абстракции и аргументу назначаются типы, что позволяет исключать некорректные выражения (например, ситуацию, когда функция применяется сама к себе неподходящим образом).\nДальнейшее развитие\n\nПолиморфные типы (System F, Жирар/Рейнольдс)\n\nЗависимые типы (Мартин-Лёф, Пер Мартин-Лёф)\n\nСвязь «Curry—Howard Correspondence» — соответствие между термами лямбда-исчисления и доказательствами в интуиционистской логике.\n\n\nВсё это привело к появлению целой иерархии типизированных лямбда-систем, которые легли в основу современных теорий типов и конструктивной математики.\n\n\n\n\n\nФункциональные языки\nНа идеях лямбда-исчисления базируются Lisp, Haskell, OCaml, F#, а также многие языки, поддерживающие функциональные парадигмы.\nТеория компиляторов\nКонцепции лямбда-исчисления лежат в основе проектирования и реализации компиляторов для высокоуровневых языков.\nФормальная верификация\nТипизированные версии лямбда-исчисления используются в системах проверки доказательств (Coq, Agda, Lean), где каждая программа является одновременно и термом, и доказательством некоторых логических свойств.",
    "crumbs": [
      "Краткая история появления лямбда-исчисления"
    ]
  },
  {
    "objectID": "docs/History.html#краткая-история-появления-лямбда-исчисления",
    "href": "docs/History.html#краткая-история-появления-лямбда-исчисления",
    "title": "λ-исчисление",
    "section": "",
    "text": "Фундаментализация математики\nВ начале XX века математики (особенно Давид Гильберт и его последователи) стремились создать строгую формальную основу для всей математики. Важную роль в этом поиске играло формализованное описание функций и самого понятия «вычисления».\nЛогические парадоксы\nВозникновение парадоксов в теории множеств (парадокс Рассела, парадокс Бурали-Форти) поставило под сомнение классические подходы к обоснованию математики и подтолкнуло учёных искать более безопасные формальные системы, свободные от противоречий.\n\n\n\n\n\n\nПервоначальные публикации\nС 1932 по 1936 год Алонзо Чёрч опубликовал ряд статей, посвящённых формализации понятия «вычислимая функция». Он представил идею лямбда-исчисления, в котором любая функция задаётся путём лямбда-абстракции и аппликации (применения к аргументам).\nСистема символического манипулирования\nЛямбда-исчисление Чёрча было задумано как способ манипулировать функциями в чисто символическом виде. В нём можно выражать и комбинировать функции, не ссылаясь на их «внутреннее строение».\nСтивен Клини и Джон Россер\nПод руководством Чёрча работала группа математиков, среди них — Клини и Россер, которые помогали развивать и уточнять основы лямбда-исчисления и расширяли теорию рекурсивных функций.\n\n\n\n\n\n\nРаботы Алана Тьюринга\nВ 1936 году Алан Тьюринг представил абстрактную машину (машину Тьюринга), призванную формализовать понятие алгоритма. Тьюринг доказал, что класс функций, вычислимых на машине Тьюринга, совпадает с классом функций, которые можно определить в лямбда-исчислении.\nТезис Чёрча — Тьюринга\nНа основе этих результатов сформировался тезис (не имеющий строгого доказательства, но общепризнанный), согласно которому все «разумные» модели вычислений (машины Тьюринга, лямбда-исчисление, рекурсивные функции) обладают одинаковой вычислительной мощностью.\n\n\n\n\n\n\nПроблема парадоксов\nУже в 1930-е годы стало ясно, что «чистое» лямбда-исчисление может приводить к логическим парадоксам (например, парадоксу Клини – Россера), если рассматривать его как базис для формальной логики без дополнительных ограничений.\nВведение типов (Simply Typed Lambda Calculus)\nПервым, кто предложил теорию, свободную от парадокса Рассела, был сам Рассел. Он разработал теорию типов. В основе этой теории лежит следующая идея: простые объекты в этой теории имеют тип 0, множества простых объектов имеют тип 1, множества множеств простых объектов имеют тип 2 и так далее. Таким образом, ни одно множество не может иметь себя в качестве элемента. В ней были свои проблемы, поэтому распространения она не получила.\nЧтобы избежать этих парадоксов, Алонзо Чёрч в 1940 году предложил типизированную версию лямбда-исчисления (так называемый Simply Typed Lambda Calculus). В этой системе каждой лямбда-абстракции и аргументу назначаются типы, что позволяет исключать некорректные выражения (например, ситуацию, когда функция применяется сама к себе неподходящим образом).\nДальнейшее развитие\n\nПолиморфные типы (System F, Жирар/Рейнольдс)\n\nЗависимые типы (Мартин-Лёф, Пер Мартин-Лёф)\n\nСвязь «Curry—Howard Correspondence» — соответствие между термами лямбда-исчисления и доказательствами в интуиционистской логике.\n\n\nВсё это привело к появлению целой иерархии типизированных лямбда-систем, которые легли в основу современных теорий типов и конструктивной математики.\n\n\n\n\n\nФункциональные языки\nНа идеях лямбда-исчисления базируются Lisp, Haskell, OCaml, F#, а также многие языки, поддерживающие функциональные парадигмы.\nТеория компиляторов\nКонцепции лямбда-исчисления лежат в основе проектирования и реализации компиляторов для высокоуровневых языков.\nФормальная верификация\nТипизированные версии лямбда-исчисления используются в системах проверки доказательств (Coq, Agda, Lean), где каждая программа является одновременно и термом, и доказательством некоторых логических свойств.",
    "crumbs": [
      "Краткая история появления лямбда-исчисления"
    ]
  },
  {
    "objectID": "docs/History.html#заключение",
    "href": "docs/History.html#заключение",
    "title": "λ-исчисление",
    "section": "Заключение",
    "text": "Заключение\nЛямбда-исчисление возникло как попытка создать строгий формализм для описания функций и вычислимости в рамках математической логики. Благодаря исследованиям Алонзо Чёрча, Алана Тьюринга и их коллег, оно стало краеугольным камнем теории вычислимости. Введение типов в лямбда-исчисление сыграло важную роль в предотвращении парадоксов и послужило основой для дальнейшего развития теории типов, логики и функционального программирования.",
    "crumbs": [
      "Краткая история появления лямбда-исчисления"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html",
    "href": "docs/lambda-calculus.html",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "t ::=\n    x  # переменная (variable)\n    | λx.t  # абстракция (lambda abstraction)\n    | t t  # применение (application)\n\n\n\n\n\nЛево-ассоциативность применения:\n\nt1 t2 t3 = (t1 t2) t3\n\nТело абстакции идёт до конца выражения:\n\nλx.λy.x y = λx.(λy.(x y))\n\nλx.λy.x y z = λx.(λy.((x y) z))\n\n\n\n\n\nПеременные связываются абстракциями:\n\nλx.t\n# Если `x` входит в `t`,\n# то `x` связан (bound) абстракцией\n# `λx` — связывающие определение (binder)\n#  с областью видимости `t`\nx y # `x` свободен\nλy.x y # `x` свободен\n\nλx.x # `x` связан\nλz.λx.λy.x (y z) # `x` связан\n\n(λx.x) x # Первый `x` связан, второй свободен\n\n\n\n\nЗамкнутый (closed) терм — терм без свободных переменных\nλx.x # Комбинатор тождества\nid = λx.x\n\n\n\n\n(λx.t) u → t[x := u]\nt[x := u] — терм t, в котором все свободные вхождения x заменены на u\n\n\n\n\n\nПрименение комбинатора тождества к переменной:\n\n(λx.x) y → x[x := y] = y\n\nПрименение комбинатора тождества к комбинатору тождества:\n\n(λx.x) (λx.x) → x[x := (λx.x)] = λx.x\n\nЛево-ассоциативность\n\n(λx.x) (λx.x) y → x[x := (λx.x)] y = λx.x y\n\n\n\n\n\n\n\nВыбор следующего редекса не зависит от порядка\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) ((λx.x) (λz.z))\n→ (λx.x) (λz.z)\n→ λz.z\n\n\n\nВсегда редуцируется самый левый внешний редекс\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z\n→ λz.z\n\n\n\nВсегда редуцируется самый левый внешний редекс, который не содержит абстракций\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z  # Не редуцируется\n\n\n\nВсегда редуцируется самый левый внешний редекс, который не содержит абстракций и не является переменной\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z  # Не редуцируется\n\n\n\n\nИх нет, но есть есть функции высшего порядка\nf = λ(x, y).s  # Такого терма нет\nf = λx.λy.s  # Вместо этого используется каррирование\nf v w = (f v) w → ((λx.λy.s) v) w → (λy.s[x := v]) w → s[x := v][y := w]\n\n\n\n\nx[x := u] = u\ny[x := u] = y\n(λy.t)[x := u] = λy.t[x := u]\n(t1 t2)[x := u] = t1[x := u] t2[x := u]\n(λx.x)[x := u] != λx.u # x связан\n(λx.x)[x := u] = λx.x # подстановка должна заканчиваться на связанной переменной\n(λx.y)[y := x] = λx.x # y свободен\n# x при подстановке тоже не связан\n# но в результате подстановки мы получили\n# связанную переменную — захватили свободную переменную\n\n\n(λx.s) = (λy.s[x := y])\n\n\n\nx[x := u] = u\ny[x := u] = y # если `y` != `x`\n(λy.t)[x := u] = λy.t[x := u] # если `y` != `x` и `y` не свободен в `u`\n(t1 t2)[x := u] = t1[x := u] t2[x := u]",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#определение",
    "href": "docs/lambda-calculus.html#определение",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "t ::=\n    x  # переменная (variable)\n    | λx.t  # абстракция (lambda abstraction)\n    | t t  # применение (application)",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#соглашения",
    "href": "docs/lambda-calculus.html#соглашения",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Лево-ассоциативность применения:\n\nt1 t2 t3 = (t1 t2) t3\n\nТело абстакции идёт до конца выражения:\n\nλx.λy.x y = λx.(λy.(x y))\n\nλx.λy.x y z = λx.(λy.((x y) z))",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#область-видимости",
    "href": "docs/lambda-calculus.html#область-видимости",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Переменные связываются абстракциями:\n\nλx.t\n# Если `x` входит в `t`,\n# то `x` связан (bound) абстракцией\n# `λx` — связывающие определение (binder)\n#  с областью видимости `t`\nx y # `x` свободен\nλy.x y # `x` свободен\n\nλx.x # `x` связан\nλz.λx.λy.x (y z) # `x` связан\n\n(λx.x) x # Первый `x` связан, второй свободен",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#замкнутый-терм.-комбинатор",
    "href": "docs/lambda-calculus.html#замкнутый-терм.-комбинатор",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Замкнутый (closed) терм — терм без свободных переменных\nλx.x # Комбинатор тождества\nid = λx.x",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#бета-редукция",
    "href": "docs/lambda-calculus.html#бета-редукция",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "(λx.t) u → t[x := u]\nt[x := u] — терм t, в котором все свободные вхождения x заменены на u",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#примеры",
    "href": "docs/lambda-calculus.html#примеры",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Применение комбинатора тождества к переменной:\n\n(λx.x) y → x[x := y] = y\n\nПрименение комбинатора тождества к комбинатору тождества:\n\n(λx.x) (λx.x) → x[x := (λx.x)] = λx.x\n\nЛево-ассоциативность\n\n(λx.x) (λx.x) y → x[x := (λx.x)] y = λx.x y",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#статегии-редукции",
    "href": "docs/lambda-calculus.html#статегии-редукции",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Выбор следующего редекса не зависит от порядка\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) ((λx.x) (λz.z))\n→ (λx.x) (λz.z)\n→ λz.z\n\n\n\nВсегда редуцируется самый левый внешний редекс\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z\n→ λz.z\n\n\n\nВсегда редуцируется самый левый внешний редекс, который не содержит абстракций\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z  # Не редуцируется\n\n\n\nВсегда редуцируется самый левый внешний редекс, который не содержит абстракций и не является переменной\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z  # Не редуцируется",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#функции-нескольких-аргументов",
    "href": "docs/lambda-calculus.html#функции-нескольких-аргументов",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Их нет, но есть есть функции высшего порядка\nf = λ(x, y).s  # Такого терма нет\nf = λx.λy.s  # Вместо этого используется каррирование\nf v w = (f v) w → ((λx.λy.s) v) w → (λy.s[x := v]) w → s[x := v][y := w]",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#подстановка",
    "href": "docs/lambda-calculus.html#подстановка",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "x[x := u] = u\ny[x := u] = y\n(λy.t)[x := u] = λy.t[x := u]\n(t1 t2)[x := u] = t1[x := u] t2[x := u]\n(λx.x)[x := u] != λx.u # x связан\n(λx.x)[x := u] = λx.x # подстановка должна заканчиваться на связанной переменной\n(λx.y)[y := x] = λx.x # y свободен\n# x при подстановке тоже не связан\n# но в результате подстановки мы получили\n# связанную переменную — захватили свободную переменную\n\n\n(λx.s) = (λy.s[x := y])\n\n\n\nx[x := u] = u\ny[x := u] = y # если `y` != `x`\n(λy.t)[x := u] = λy.t[x := u] # если `y` != `x` и `y` не свободен в `u`\n(t1 t2)[x := u] = t1[x := u] t2[x := u]",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/Lambda_vs_Turing.html",
    "href": "docs/Lambda_vs_Turing.html",
    "title": "λ-исчисление",
    "section": "",
    "text": "По сути, они обе полны по Тьюрингу, одно можно заменить другим.",
    "crumbs": [
      "Различия"
    ]
  },
  {
    "objectID": "docs/Lambda_vs_Turing.html#различия",
    "href": "docs/Lambda_vs_Turing.html#различия",
    "title": "λ-исчисление",
    "section": "Различия",
    "text": "Различия\nРазница представлена в виде таблицы:\n\n\n\n\n\n\n\n\nКритерий\nLambda\nTuring\n\n\n\n\nМодель\nАбстрактная математическая модель, основанная на функциях и их применении.\nАбстрактный автомат с лентой и таблицей переходов.\n\n\nФорма\nВычисления задаются через функциональные преобразования и рекурсию.\nОперации определяются через пошаговые модификации ленты и состояния.\n\n\nДекларативность\nБольше ориентировано на выражение функций.\nИнструкции описывают шаги выполнения.\n\n\nАбстракция\nВысокий уровень абстракции. Математическая чистота.\nБолее низкий уровень, приближённый к реальному исполнению на машине.\n\n\nВыражение алгоритмов\nКомпозиция функций.\nСостояния и пошаговое изменение ленты.\n\n\nЧитаемость\nБолее сложное для восприятия новичками из-за чисто функционального подхода.\nБолее наглядное для имитации конкретного вычислительного процесса.",
    "crumbs": [
      "Различия"
    ]
  },
  {
    "objectID": "docs/Lambda_vs_Turing.html#плюсы-и-минусы",
    "href": "docs/Lambda_vs_Turing.html#плюсы-и-минусы",
    "title": "λ-исчисление",
    "section": "Плюсы и минусы",
    "text": "Плюсы и минусы\n\nLabmda\nПлюсы: - Высокий уровень абстракции: позволяет описывать вычисления чисто математически. - Функциональный стиль: компактное и декларативное представление программ. - Математическая чистота: формальные доказательства корректности функций проще проводить. - Близость к современным языкам программирования: многие языки (например, Haskell, Lisp) используют идеи лямбда-исчисления.\nМинусы: - Трудности интерпретации: выполнение требует преобразования функций, что сложно для понимания. - Ограниченность моделирования состояния: отсутствие “пошагового” изменения состояния, как в императивных моделях. - Сложность реализации: для реального железа необходимо трансформировать выражения в машинные инструкции.\n\n\nTuring\nПлюсы: - Наглядность и интуитивность: легко представить вычисление как последовательность шагов. - Приближенность к аппаратному исполнению: модели состояния близки к работе процессоров. - Гибкость моделирования: можно выразить любые алгоритмы с дискретным изменением памяти. - Основа императивного программирования: родоначальник современных языков и архитектуры компьютеров.\nМинусы: - Низкий уровень абстракции: описания вычислений могут быть громоздкими. - Медлительность: моделирование сложных алгоритмов требует большого количества шагов. - Неудобство для функционального стиля: для чисто математических выражений менее эффективен.",
    "crumbs": [
      "Различия"
    ]
  },
  {
    "objectID": "docs/Lambda_vs_Turing.html#что-лучше-делать-на-каждом",
    "href": "docs/Lambda_vs_Turing.html#что-лучше-делать-на-каждом",
    "title": "λ-исчисление",
    "section": "Что лучше делать на каждом?",
    "text": "Что лучше делать на каждом?\n\nLambda\n\nФункциональное программирование: когда нужно выразить вычисления через композицию функций (например, рекурсивные алгоритмы).\nДоказательства корректности алгоритмов: благодаря чисто математическому подходу.\nРазработка теоретических моделей вычислений: например, исследование вычислимости функций или формального анализа программ.\nКомбинаторные вычисления: системы, использующие функции высшего порядка.\n\n\n\nTuring\n\nМоделирование пошаговых вычислений: например, алгоритмы работы памяти или устройства.\nИмперативные алгоритмы: программы, работающие со состоянием и изменяющие память (циклы, присваивания).\nСоздание симуляторов реального оборудования: имитация работы процессоров, интерпретаторов.\nТеоретические исследования конечных автоматов и их расширений.",
    "crumbs": [
      "Различия"
    ]
  },
  {
    "objectID": "docs/Lambda_vs_Turing.html#пример-алгоритма-сложения",
    "href": "docs/Lambda_vs_Turing.html#пример-алгоритма-сложения",
    "title": "λ-исчисление",
    "section": "Пример алгоритма сложения",
    "text": "Пример алгоритма сложения\n\nlambda\nadd = λm.λn.λf.λx. m f (n f x)\n\nadd 2 3\n= (λm.λn.λf.λx. m f (n f x)) 2 3\n\nadd 2 3 = λf.λx. (λf.λx.f (f x)) f ((λf.λx.f (f (f x))) f x)\n\n\nTuring\nq0 1 &gt; q0 1 R\nq0 # &gt; q1 # R\nq1 1 &gt; q2 E L\nq 2 1 &gt; q2 1 L\nq2 # &gt; q0 # R\nq0 E &gt; qf E Stop\n\n111#11 &gt; 11111",
    "crumbs": [
      "Различия"
    ]
  },
  {
    "objectID": "presentation/presentation.html#история-появления",
    "href": "presentation/presentation.html#история-появления",
    "title": "λ-исчисление",
    "section": "История появления",
    "text": "История появления\n\nФреге 1893\n\n\\[A + B = (\\oplus(A))(B)\\]\n\nРассел 1910. Теория типов\nШейнфинкель 1924\nЧёрчь 1932\n\n\\[\nλx.M\n\\]",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#зачем-придумана-теория-типов",
    "href": "presentation/presentation.html#зачем-придумана-теория-типов",
    "title": "λ-исчисление",
    "section": "Зачем придумана теория типов",
    "text": "Зачем придумана теория типов\n\nВ наивной теории множеств существует парадокс Рассела\nТипы создают иерахию объектов, исключая самоссылку\nОграничение допустимых формул",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#определие-λ-исчесления.-термы",
    "href": "presentation/presentation.html#определие-λ-исчесления.-термы",
    "title": "λ-исчисление",
    "section": "Определие λ-исчесления. Термы",
    "text": "Определие λ-исчесления. Термы\nt ::=\n    x  # переменная (variable)\n    | λx.t  # абстракция (lambda abstraction)\n    | t t  # применение (application)\n\nСоглашения\n\nЛево-ассоциативность применения:\n\nt1 t2 t3 = (t1 t2) t3\n\nТело абстакции идёт до конца выражения:\n\nλx. x y = λx. (x y)\n\nλx.λy.x y = λx.(λy.(x y))\n\nλx.λy.x y z = λx.(λy.((x y) z))",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#примеры",
    "href": "presentation/presentation.html#примеры",
    "title": "λ-исчисление",
    "section": "Примеры",
    "text": "Примеры\n\n\nКомбинатор тождества\n\n(λx.x) y \n→ x[x := y] \n= y\n\n\n\n\n\n(λx.x) (λx.x) → \nx[x := (λx.x)] \n= λx.x\n\n\n\nЛево-ассоциативность\n\n(λx.x) (λx.x) y \n→ x[x := (λx.x)] y \n= λx.x y",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#формализация.-beta-редукция",
    "href": "presentation/presentation.html#формализация.-beta-редукция",
    "title": "λ-исчисление",
    "section": "Формализация. \\(\\beta\\)-редукция",
    "text": "Формализация. \\(\\beta\\)-редукция\n(λx.t) u → t[x := u]\nЗаменяем в терме \\(t\\) вхождения \\(x\\) на \\(u\\) и убираем λ, то есть редуцируем.\n\n\\(\\beta\\)-редукция — вычисление в λ-исчеслении",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#true-false-if",
    "href": "presentation/presentation.html#true-false-if",
    "title": "λ-исчисление",
    "section": "true, false, if",
    "text": "true, false, if\nВведем константы\ntru = λt. λf. t # возвращает первый аргумент\nfls = λt. λf. f # возвращает второй аргумент\nВведем функцию test — аналог if-else\ntest = λl. λm. λn. l m n\n\nПример\ntest tru v w = \n= (λl. λm. λn. l m n) tru v w →\n→ (λm. λn. tru m n) v w →\n→ (λn. tru v n) w →\n→ tru v w =\n= (λt. λf. t) v w →\n→ (λf. v) w →\n→ v",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#бесконечная-саморедукция",
    "href": "presentation/presentation.html#бесконечная-саморедукция",
    "title": "λ-исчисление",
    "section": "Бесконечная саморедукция",
    "text": "Бесконечная саморедукция\n(λx.x x) y → y y\n\n(λx.x x) (λx.x x) →\n→ (λx.x x) (λx.x x) →\n...",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#подстановка",
    "href": "presentation/presentation.html#подстановка",
    "title": "λ-исчисление",
    "section": "Подстановка",
    "text": "Подстановка\nx[x := u] = u\ny[x := u] = y\n(λy.t)[x := u] = λy.t[x := u]\n(t1 t2)[x := u] = t1[x := u] t2[x := u]\n\nλ связывает переменные\n(λx.x)[x := u] != λx.u  # x связан\n(λx.x)[x := u] = λx.x   # подстановка должна заканчиваться на связанной переменной\n\n\nНО\n(λx.y)[y := x] = λx.x # y свободен — x при подстановке должен остаться не связаным,\n# но в результате подстановки мы получили\n# связанную переменную — захватили свободную переменную",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#решение.-alpha-конверсия",
    "href": "presentation/presentation.html#решение.-alpha-конверсия",
    "title": "λ-исчисление",
    "section": "Решение. \\(\\alpha\\)-конверсия",
    "text": "Решение. \\(\\alpha\\)-конверсия\n(λx.s) = (λy.s[x := y])",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#сравнение-с-языками-программирования",
    "href": "presentation/presentation.html#сравнение-с-языками-программирования",
    "title": "λ-исчисление",
    "section": "Сравнение с языками программирования",
    "text": "Сравнение с языками программирования\nλ-исчесление\nλx.λy.(x + y)\nPython\nadd = lambda x: lambda y: x + y\nJS\nconst add = x =&gt; y =&gt; x + y;\nHaskell\nadd :: Int -&gt; Int -&gt; Int\nadd x y = x + y\n-- или\nadd = \\x -&gt; \\y -&gt; x + y",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#типы",
    "href": "presentation/presentation.html#типы",
    "title": "λ-исчисление",
    "section": "Типы",
    "text": "Типы\nВведем множестно типов переменных \\(\\mathcal{X}\\). И населим его одним базовым типом \\(\\circ\\)\n\\[\\mathcal{X} = \\{\\circ\\}\\]\n\\[\n\\begin{align}\n& x^\\circ \\\\\n& y^\\circ \\\\\n\\\\\n& f = λx^\\circ .y^\\circ \\\\\n& f^{\\circ→\\circ}\n\\end{align}\n\\]",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#типы.-bool-и-nat",
    "href": "presentation/presentation.html#типы.-bool-и-nat",
    "title": "λ-исчисление",
    "section": "Типы. Bool и Nat",
    "text": "Типы. Bool и Nat\n\\[\n\\begin{align}\n& true = λt^\\circ. λf^\\circ. t \\\\\n& false = λt^\\circ. λf^\\circ. f \\\\\n& Bool = \\circ → \\circ → \\circ\\ \\\\\n\\\\\n& zero = λs^{\\circ→\\circ}. λz^\\circ. z\\\\\n& succ = λn. λs. λz^\\circ. s\\ n\\ s\\ z \\\\\n& one = succ\\ zero = λs. λz^\\circ. s\\ z\\\\\n& ... \\\\\n& Nat = (\\circ → \\circ) → \\circ → \\circ\n\\end{align}\n\\]",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#типизация-по-черчу",
    "href": "presentation/presentation.html#типизация-по-черчу",
    "title": "λ-исчисление",
    "section": "Типизация по Черчу",
    "text": "Типизация по Черчу\n\nКаждая константа имеет свой тип\nВ каждом типе есть свой счетный набор переменных\n\n\\[\n\\begin{align}\n& u:\\beta  \\text{ переменная } u \\text{ имеет жестко заданный тип } \\beta \\\\\n& u:\\beta \\implies (λx^\\sigma.u) : \\beta \\\\\n& u:(\\alpha → \\beta),\\ v:\\alpha  \\implies u\\ v : \\beta\n\\end{align}\n\\]",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#типизация-по-карри",
    "href": "presentation/presentation.html#типизация-по-карри",
    "title": "λ-исчисление",
    "section": "Типизация по Карри",
    "text": "Типизация по Карри\n\nТермы остаются такие же как и в бестиповом\nВводиться отношение типизируемости\nДля свободных переменных типы задаются явно\nОстальные типы выводятся",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#типизация-по-карри-1",
    "href": "presentation/presentation.html#типизация-по-карри-1",
    "title": "λ-исчисление",
    "section": "Типизация по Карри",
    "text": "Типизация по Карри\n\\(\\Gamma \\vdash u:b\\)\nЕсли из контекста имеется вывод, что \\(u:b\\) тогда \\(u\\) может иметь тип \\(b\\)\n\n\\(\\Gamma, x:\\alpha \\vdash x : \\alpha\\)\n\n\n\\(\\Gamma \\vdash u: (\\alpha → \\beta),\\ \\Gamma \\vdash v : \\alpha \\implies \\Gamma \\vdash (uv) : \\beta\\)\n\n\n\\(\\Gamma, x : \\alpha \\vdash u : \\beta \\implies \\Gamma \\vdash (λx. u) : (\\alpha → \\beta)\\)",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#коротко",
    "href": "presentation/presentation.html#коротко",
    "title": "λ-исчисление",
    "section": "Коротко",
    "text": "Коротко\nТипизация по Черчу\n\nПереопределяются термы\nВсё имеет заданный жесткий тип\n\nТипизация по Карри\n\nТермы такие же как в бестиповом\nТипы выводятся\nДля некоторых термов может не существовать типа",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#выгода-типизации",
    "href": "presentation/presentation.html#выгода-типизации",
    "title": "λ-исчисление",
    "section": "Выгода типизации",
    "text": "Выгода типизации\n\nЗапрет конструкций (λx.x x) (λx.x x), т.к. она не имеет типа.\nСтатический контроль. \\(\\beta\\)-редукция сохраняет тип выражения\n\n\nλx.x x — не имеет типа",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#тьюринг-vs-lambda",
    "href": "presentation/presentation.html#тьюринг-vs-lambda",
    "title": "λ-исчисление",
    "section": "Тьюринг vs Lambda",
    "text": "Тьюринг vs Lambda\nλ-исчиление\n\nОриентирован на математические функции\nКомпозиция функций\nВысокая абстрация\n\nМашина Тьюринга\n\nАвтомат с лентой таблицей переходов\nДискретные состояния и пошаговое изменение ленты\nЯвное представление",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#сложение-чисел",
    "href": "presentation/presentation.html#сложение-чисел",
    "title": "λ-исчисление",
    "section": "Сложение чисел",
    "text": "Сложение чисел\nλ-исчесление\n2 = λs λz s (s z)\n3 = λs λz s (s (s z))\nadd = λm. λn. λs. λz. m s (n s z)\n\nadd 2 3\nМашина Тьюринга\nq0 1 → q0 1 R\nq0 # → q0 # R\nq1 1 → q2 ε L\nq2 1 → q2 1 L\nq2 # → q0 1 R\nq0 ε → q0 ε N\n\n111#11 &gt; 11111",
    "crumbs": [
      "Презентация"
    ]
  }
]