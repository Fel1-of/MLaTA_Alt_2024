[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "λ-исчисление",
    "section": "",
    "text": "λ-исчисление\n\n\nПрезентация по λ-исчислению\n\n\n\nРыжиков И.С., Комосский Е.А.\n\n\n\n\n\n\n\n\n\n\n\n\nКраткая история появления лямбда-исчисления\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nНетипизированное лямбда-исчисление\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПросто типизированное лямбда-исчисление (Simple Type Theory)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nРазличия между Lambda и Turing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nРекурсия\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nСистемы типизации лямбда-исчисления\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Главная"
    ]
  },
  {
    "objectID": "docs/History.html",
    "href": "docs/History.html",
    "title": "λ-исчисление",
    "section": "",
    "text": "Фундаментализация математики\nВ начале XX века математики (особенно Давид Гильберт и его последователи) стремились создать строгую формальную основу для всей математики. Важную роль в этом поиске играло формализованное описание функций и самого понятия «вычисления».\nЛогические парадоксы\nВозникновение парадоксов в теории множеств (парадокс Рассела, парадокс Бурали-Форти) поставило под сомнение классические подходы к обоснованию математики и подтолкнуло учёных искать более безопасные формальные системы, свободные от противоречий.\n\n\n\n\n\n\nПервоначальные публикации\nС 1932 по 1936 год Алонзо Чёрч опубликовал ряд статей, посвящённых формализации понятия «вычислимая функция». Он представил идею лямбда-исчисления, в котором любая функция задаётся путём лямбда-абстракции и аппликации (применения к аргументам).\nСистема символического манипулирования\nЛямбда-исчисление Чёрча было задумано как способ манипулировать функциями в чисто символическом виде. В нём можно выражать и комбинировать функции, не ссылаясь на их «внутреннее строение».\nСтивен Клини и Джон Россер\nПод руководством Чёрча работала группа математиков, среди них — Клини и Россер, которые помогали развивать и уточнять основы лямбда-исчисления и расширяли теорию рекурсивных функций.\n\n\n\n\n\n\nРаботы Алана Тьюринга\nВ 1936 году Алан Тьюринг представил абстрактную машину (машину Тьюринга), призванную формализовать понятие алгоритма. Тьюринг доказал, что класс функций, вычислимых на машине Тьюринга, совпадает с классом функций, которые можно определить в лямбда-исчислении.\nТезис Чёрча — Тьюринга\nНа основе этих результатов сформировался тезис (не имеющий строгого доказательства, но общепризнанный), согласно которому все «разумные» модели вычислений (машины Тьюринга, лямбда-исчисление, рекурсивные функции) обладают одинаковой вычислительной мощностью.\n\n\n\n\n\n\nПроблема парадоксов\nУже в 1930-е годы стало ясно, что «чистое» лямбда-исчисление может приводить к логическим парадоксам (например, парадоксу Клини – Россера), если рассматривать его как базис для формальной логики без дополнительных ограничений.\nВведение типов (Simply Typed Lambda Calculus)\nПервым, кто предложил теорию, свободную от парадокса Рассела, был сам Рассел. Он разработал теорию типов. В основе этой теории лежит следующая идея: простые объекты в этой теории имеют тип 0, множества простых объектов имеют тип 1, множества множеств простых объектов имеют тип 2 и так далее. Таким образом, ни одно множество не может иметь себя в качестве элемента. В ней были свои проблемы, поэтому распространения она не получила.\nЧтобы избежать этих парадоксов, Алонзо Чёрч в 1940 году предложил типизированную версию лямбда-исчисления (так называемый Simply Typed Lambda Calculus). В этой системе каждой лямбда-абстракции и аргументу назначаются типы, что позволяет исключать некорректные выражения (например, ситуацию, когда функция применяется сама к себе неподходящим образом).\nДальнейшее развитие\n\nПолиморфные типы (System F, Жирар/Рейнольдс)\n\nЗависимые типы (Мартин-Лёф, Пер Мартин-Лёф)\n\nСвязь «Curry—Howard Correspondence» — соответствие между термами лямбда-исчисления и доказательствами в интуиционистской логике.\n\n\nВсё это привело к появлению целой иерархии типизированных лямбда-систем, которые легли в основу современных теорий типов и конструктивной математики.\n\n\n\n\n\nФункциональные языки\nНа идеях лямбда-исчисления базируются Lisp, Haskell, OCaml, F#, а также многие языки, поддерживающие функциональные парадигмы.\nТеория компиляторов\nКонцепции лямбда-исчисления лежат в основе проектирования и реализации компиляторов для высокоуровневых языков.\nФормальная верификация\nТипизированные версии лямбда-исчисления используются в системах проверки доказательств (Coq, Agda, Lean), где каждая программа является одновременно и термом, и доказательством некоторых логических свойств.",
    "crumbs": [
      "Краткая история появления лямбда-исчисления"
    ]
  },
  {
    "objectID": "docs/History.html#краткая-история-появления-лямбда-исчисления",
    "href": "docs/History.html#краткая-история-появления-лямбда-исчисления",
    "title": "λ-исчисление",
    "section": "",
    "text": "Фундаментализация математики\nВ начале XX века математики (особенно Давид Гильберт и его последователи) стремились создать строгую формальную основу для всей математики. Важную роль в этом поиске играло формализованное описание функций и самого понятия «вычисления».\nЛогические парадоксы\nВозникновение парадоксов в теории множеств (парадокс Рассела, парадокс Бурали-Форти) поставило под сомнение классические подходы к обоснованию математики и подтолкнуло учёных искать более безопасные формальные системы, свободные от противоречий.\n\n\n\n\n\n\nПервоначальные публикации\nС 1932 по 1936 год Алонзо Чёрч опубликовал ряд статей, посвящённых формализации понятия «вычислимая функция». Он представил идею лямбда-исчисления, в котором любая функция задаётся путём лямбда-абстракции и аппликации (применения к аргументам).\nСистема символического манипулирования\nЛямбда-исчисление Чёрча было задумано как способ манипулировать функциями в чисто символическом виде. В нём можно выражать и комбинировать функции, не ссылаясь на их «внутреннее строение».\nСтивен Клини и Джон Россер\nПод руководством Чёрча работала группа математиков, среди них — Клини и Россер, которые помогали развивать и уточнять основы лямбда-исчисления и расширяли теорию рекурсивных функций.\n\n\n\n\n\n\nРаботы Алана Тьюринга\nВ 1936 году Алан Тьюринг представил абстрактную машину (машину Тьюринга), призванную формализовать понятие алгоритма. Тьюринг доказал, что класс функций, вычислимых на машине Тьюринга, совпадает с классом функций, которые можно определить в лямбда-исчислении.\nТезис Чёрча — Тьюринга\nНа основе этих результатов сформировался тезис (не имеющий строгого доказательства, но общепризнанный), согласно которому все «разумные» модели вычислений (машины Тьюринга, лямбда-исчисление, рекурсивные функции) обладают одинаковой вычислительной мощностью.\n\n\n\n\n\n\nПроблема парадоксов\nУже в 1930-е годы стало ясно, что «чистое» лямбда-исчисление может приводить к логическим парадоксам (например, парадоксу Клини – Россера), если рассматривать его как базис для формальной логики без дополнительных ограничений.\nВведение типов (Simply Typed Lambda Calculus)\nПервым, кто предложил теорию, свободную от парадокса Рассела, был сам Рассел. Он разработал теорию типов. В основе этой теории лежит следующая идея: простые объекты в этой теории имеют тип 0, множества простых объектов имеют тип 1, множества множеств простых объектов имеют тип 2 и так далее. Таким образом, ни одно множество не может иметь себя в качестве элемента. В ней были свои проблемы, поэтому распространения она не получила.\nЧтобы избежать этих парадоксов, Алонзо Чёрч в 1940 году предложил типизированную версию лямбда-исчисления (так называемый Simply Typed Lambda Calculus). В этой системе каждой лямбда-абстракции и аргументу назначаются типы, что позволяет исключать некорректные выражения (например, ситуацию, когда функция применяется сама к себе неподходящим образом).\nДальнейшее развитие\n\nПолиморфные типы (System F, Жирар/Рейнольдс)\n\nЗависимые типы (Мартин-Лёф, Пер Мартин-Лёф)\n\nСвязь «Curry—Howard Correspondence» — соответствие между термами лямбда-исчисления и доказательствами в интуиционистской логике.\n\n\nВсё это привело к появлению целой иерархии типизированных лямбда-систем, которые легли в основу современных теорий типов и конструктивной математики.\n\n\n\n\n\nФункциональные языки\nНа идеях лямбда-исчисления базируются Lisp, Haskell, OCaml, F#, а также многие языки, поддерживающие функциональные парадигмы.\nТеория компиляторов\nКонцепции лямбда-исчисления лежат в основе проектирования и реализации компиляторов для высокоуровневых языков.\nФормальная верификация\nТипизированные версии лямбда-исчисления используются в системах проверки доказательств (Coq, Agda, Lean), где каждая программа является одновременно и термом, и доказательством некоторых логических свойств.",
    "crumbs": [
      "Краткая история появления лямбда-исчисления"
    ]
  },
  {
    "objectID": "docs/History.html#заключение",
    "href": "docs/History.html#заключение",
    "title": "λ-исчисление",
    "section": "Заключение",
    "text": "Заключение\nЛямбда-исчисление возникло как попытка создать строгий формализм для описания функций и вычислимости в рамках математической логики. Благодаря исследованиям Алонзо Чёрча, Алана Тьюринга и их коллег, оно стало краеугольным камнем теории вычислимости. Введение типов в лямбда-исчисление сыграло важную роль в предотвращении парадоксов и послужило основой для дальнейшего развития теории типов, логики и функционального программирования.",
    "crumbs": [
      "Краткая история появления лямбда-исчисления"
    ]
  },
  {
    "objectID": "docs/type-theory/index.html",
    "href": "docs/type-theory/index.html",
    "title": "Системы типизации лямбда-исчисления",
    "section": "",
    "text": "В лямбда-исчислении существуют различные системы типизации, которые определяют, какие термы являются корректными, а какие нет.\nСистемы типизации лямбда-исчисления можно разделить на следующие типы:\n\nПростая типизация\nСистемы с подтипами\nПолиморфные системы\nЗависимые типы\nСистемы с зависимыми типами\n\n\n\nЕсть два основных стиля типизации:\n\nСтиль Карри (Curry-style) - типы выводятся автоматически. Термы те же что и в бестиповом лямбда-исчислении. Каждый терм имеет своё множество типов: пустой множество, множество из одного типа или множество из нескольких типов или бесконечного множества типов. Типы не явно указываются в программе. Типы присваиваются (приписываются) термам.\nСтиль Чёрча (Church-style) - типы явно указываются в программе. Типы является неотъемлемой частью терма.\n\nВстречается также такая терминология:\n\nСистемы в стиле Карри — лямбда-исчисление с присваиваем типов.\nСистемы в стиле Чёрча — системы типизированного лямбда-исчисления.\n\n\n\n\nПростая типизация вводит только один тип для всех термов. В такой системе типизации каждый терм является либо атомом, либо абстракцией.\nПростая типизация не позволяет корректно типизировать термы, которые используются в различных контекстах. Например, терм λx.x x не может быть типизирован в простой типизации.\nПодробнее о простой типизации можно прочитать в статье.",
    "crumbs": [
      "Системы типизации лямбда-исчисления"
    ]
  },
  {
    "objectID": "docs/type-theory/index.html#стили-типизации",
    "href": "docs/type-theory/index.html#стили-типизации",
    "title": "Системы типизации лямбда-исчисления",
    "section": "",
    "text": "Есть два основных стиля типизации:\n\nСтиль Карри (Curry-style) - типы выводятся автоматически. Термы те же что и в бестиповом лямбда-исчислении. Каждый терм имеет своё множество типов: пустой множество, множество из одного типа или множество из нескольких типов или бесконечного множества типов. Типы не явно указываются в программе. Типы присваиваются (приписываются) термам.\nСтиль Чёрча (Church-style) - типы явно указываются в программе. Типы является неотъемлемой частью терма.\n\nВстречается также такая терминология:\n\nСистемы в стиле Карри — лямбда-исчисление с присваиваем типов.\nСистемы в стиле Чёрча — системы типизированного лямбда-исчисления.",
    "crumbs": [
      "Системы типизации лямбда-исчисления"
    ]
  },
  {
    "objectID": "docs/type-theory/index.html#простая-типизация-simple-type-theory",
    "href": "docs/type-theory/index.html#простая-типизация-simple-type-theory",
    "title": "Системы типизации лямбда-исчисления",
    "section": "",
    "text": "Простая типизация вводит только один тип для всех термов. В такой системе типизации каждый терм является либо атомом, либо абстракцией.\nПростая типизация не позволяет корректно типизировать термы, которые используются в различных контекстах. Например, терм λx.x x не может быть типизирован в простой типизации.\nПодробнее о простой типизации можно прочитать в статье.",
    "crumbs": [
      "Системы типизации лямбда-исчисления"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html",
    "href": "docs/lambda-calculus.html",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "t ::=\n    x  # переменная (variable)\n    | λx.t  # абстракция (lambda abstraction)\n    | t t  # применение (application)\n\n\n\n\n\nЛево-ассоциативность применения:\n\nt1 t2 t3 = (t1 t2) t3\n\nТело абстракции идёт до конца выражения:\n\nλx.λy.x y = λx.(λy.(x y))\n\nλx.λy.x y z = λx.(λy.((x y) z))\n\n\n\n\n\nПеременные связываются абстракциями:\n\nλx.t\n# Если `x` входит в `t`,\n# то `x` связан (bound) абстракцией\n# `λx` — связывающие определение (binder)\n#  с областью видимости `t`\nx y # `x` свободен\nλy.x y # `x` свободен\n\nλx.x # `x` связан\nλz.λx.λy.x (y z) # `x` связан\n\n(λx.x) x # Первый `x` связан, второй свободен\n\n\n\n\nЗамкнутый (closed) терм — терм без свободных переменных\nλx.x # Комбинатор тождества\nid = λx.x\n\n\n\n\n(λx.t) u → t[x := u]\nt[x := u] — терм t, в котором все свободные вхождения x заменены на u\n\n\n\n\n\nПрименение комбинатора тождества к переменной:\n\n(λx.x) y → x[x := y] = y\n\nПрименение комбинатора тождества к комбинатору тождества:\n\n(λx.x) (λx.x) → x[x := (λx.x)] = λx.x\n\nЛево-ассоциативность\n\n(λx.x) (λx.x) y → x[x := (λx.x)] y = λx.x y\n\n\n\n\n\n\n\nВыбор следующего редекса1 не зависит от порядка\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) ((λx.x) (λz.z))\n→ (λx.x) (λz.z)\n→ λz.z\n\n\n\nВсегда редуцируется самый левый внешний редекс\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z\n→ λz.z\n\n\n\nВсегда редуцируется самый левый внешний редекс, который не содержит абстракций\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z  # Не редуцируется\n\n\n\nВсегда редуцируется самый левый внешний редекс, который не содержит абстракций и не является переменной\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z  # Не редуцируется\n\n\n\n\nИх нет, но можно их симулировать используя функции высшего порядка и каррирование.\nФункция высшего порядка — функция, которая принимает функции в качестве аргументов или возвращает функции как результат.\nС помощью каррирования2 мы можем преобразовать \\(f(x, y) = M\\) в \\(f = λx.λy.M\\) — последовательность функций, каждая из которых принимает по одному аргументу.\nf = λ(x, y).M  # Такого терма нет\nf = λx.λy.M  # Вместо этого используется каррирование\nf v w = (f v) w → ((λx.λy.M) v) w → (λy.M[x := v]) w → M[x := v][y := w]\nПервое применение вернет функцию \\(λy.M[x := v]\\), которая сможет принят второй аргумент.\n\n\n\n\nx[x := u] = u\ny[x := u] = y\n(λy.t)[x := u] = λy.t[x := u]\n(t1 t2)[x := u] = t1[x := u] t2[x := u]\n(λx.x)[x := u] != λx.u # x связан\n(λx.x)[x := u] = λx.x # подстановка должна заканчиваться на связанной переменной\n(λx.y)[y := x] = λx.x # y свободен\n# x при подстановке тоже не связан\n# но в результате подстановки мы получили\n# связанную переменную — захватили свободную переменную\n\n\n(λx.s) = (λy.s[x := y])\n\n\n\nx[x := u] = u\ny[x := u] = y # если `y` != `x`\n(λy.t)[x := u] = λy.t[x := u] # если `y` != `x` и `y` не свободен в `u`\n(t1 t2)[x := u] = t1[x := u] t2[x := u]",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#определение",
    "href": "docs/lambda-calculus.html#определение",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "t ::=\n    x  # переменная (variable)\n    | λx.t  # абстракция (lambda abstraction)\n    | t t  # применение (application)",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#соглашения",
    "href": "docs/lambda-calculus.html#соглашения",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Лево-ассоциативность применения:\n\nt1 t2 t3 = (t1 t2) t3\n\nТело абстракции идёт до конца выражения:\n\nλx.λy.x y = λx.(λy.(x y))\n\nλx.λy.x y z = λx.(λy.((x y) z))",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#область-видимости",
    "href": "docs/lambda-calculus.html#область-видимости",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Переменные связываются абстракциями:\n\nλx.t\n# Если `x` входит в `t`,\n# то `x` связан (bound) абстракцией\n# `λx` — связывающие определение (binder)\n#  с областью видимости `t`\nx y # `x` свободен\nλy.x y # `x` свободен\n\nλx.x # `x` связан\nλz.λx.λy.x (y z) # `x` связан\n\n(λx.x) x # Первый `x` связан, второй свободен",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#замкнутый-терм.-комбинатор",
    "href": "docs/lambda-calculus.html#замкнутый-терм.-комбинатор",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Замкнутый (closed) терм — терм без свободных переменных\nλx.x # Комбинатор тождества\nid = λx.x",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#бета-редукция",
    "href": "docs/lambda-calculus.html#бета-редукция",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "(λx.t) u → t[x := u]\nt[x := u] — терм t, в котором все свободные вхождения x заменены на u",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#примеры",
    "href": "docs/lambda-calculus.html#примеры",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Применение комбинатора тождества к переменной:\n\n(λx.x) y → x[x := y] = y\n\nПрименение комбинатора тождества к комбинатору тождества:\n\n(λx.x) (λx.x) → x[x := (λx.x)] = λx.x\n\nЛево-ассоциативность\n\n(λx.x) (λx.x) y → x[x := (λx.x)] y = λx.x y",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#стратегии-редукции",
    "href": "docs/lambda-calculus.html#стратегии-редукции",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Выбор следующего редекса1 не зависит от порядка\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) ((λx.x) (λz.z))\n→ (λx.x) (λz.z)\n→ λz.z\n\n\n\nВсегда редуцируется самый левый внешний редекс\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z\n→ λz.z\n\n\n\nВсегда редуцируется самый левый внешний редекс, который не содержит абстракций\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z  # Не редуцируется\n\n\n\nВсегда редуцируется самый левый внешний редекс, который не содержит абстракций и не является переменной\n(λx.x) ((λx.x) (λz.(λx.x) z))\n→ (λx.x) (λz.(λx.x) z)\n→ λz.(λx.x) z  # Не редуцируется",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#функции-нескольких-аргументов",
    "href": "docs/lambda-calculus.html#функции-нескольких-аргументов",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "Их нет, но можно их симулировать используя функции высшего порядка и каррирование.\nФункция высшего порядка — функция, которая принимает функции в качестве аргументов или возвращает функции как результат.\nС помощью каррирования2 мы можем преобразовать \\(f(x, y) = M\\) в \\(f = λx.λy.M\\) — последовательность функций, каждая из которых принимает по одному аргументу.\nf = λ(x, y).M  # Такого терма нет\nf = λx.λy.M  # Вместо этого используется каррирование\nf v w = (f v) w → ((λx.λy.M) v) w → (λy.M[x := v]) w → M[x := v][y := w]\nПервое применение вернет функцию \\(λy.M[x := v]\\), которая сможет принят второй аргумент.",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#подстановка",
    "href": "docs/lambda-calculus.html#подстановка",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "",
    "text": "x[x := u] = u\ny[x := u] = y\n(λy.t)[x := u] = λy.t[x := u]\n(t1 t2)[x := u] = t1[x := u] t2[x := u]\n(λx.x)[x := u] != λx.u # x связан\n(λx.x)[x := u] = λx.x # подстановка должна заканчиваться на связанной переменной\n(λx.y)[y := x] = λx.x # y свободен\n# x при подстановке тоже не связан\n# но в результате подстановки мы получили\n# связанную переменную — захватили свободную переменную\n\n\n(λx.s) = (λy.s[x := y])\n\n\n\nx[x := u] = u\ny[x := u] = y # если `y` != `x`\n(λy.t)[x := u] = λy.t[x := u] # если `y` != `x` и `y` не свободен в `u`\n(t1 t2)[x := u] = t1[x := u] t2[x := u]",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/lambda-calculus.html#footnotes",
    "href": "docs/lambda-calculus.html#footnotes",
    "title": "Нетипизированное лямбда-исчисление",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nЧасть выражения (терм) к которому применяется бета-редукция называется редексом.↩︎\nКаррирование — преобразование функции вида \\(f(x, y, z) = M\\) в функцию вида \\(f = λx.λy.λz.M\\), где аргументы передаются последовательно.↩︎",
    "crumbs": [
      "Нетипизированное лямбда-исчисление"
    ]
  },
  {
    "objectID": "docs/fixed-point.html",
    "href": "docs/fixed-point.html",
    "title": "Рекурсия",
    "section": "",
    "text": "Рассмотрим следующую терм \\(\\omega = λx.x\\ x\\).\nw y = (λx.x x) y → y y\nПрименим его к самой себе:\nw w = (λx.x x) (λx.x x) →\n→ (λx.x x) (λx.x x) →\n...\nЭтот процесс будет повторятся бесконечно. Процесс вычисления никогда не завершится.\nЭтот оператор имеет философское отношение к парадоксу Рассела или парадоксу Клини, когда объект, определяемый через сам себя, приводит к некорректности или бесконечности.\n\n\n\nДля любого λ-терма F существует неподвижная точка\n\\[\n\\forall F\\ \\exists X: F\\ X = X\n\\]\n\n\nВведем - \\(W = λx. F (x x)\\) - \\(X = W W\\)\nТогда\nX = W W = (λx. F (x x)) W = F (W W) = F X\n\n\n\n\nСуществует комбинатор неподвижной точки\nY = λf.(λx. f (x x))(λx. f (x x))\nтакой что \\(\\forall F:\\ F\\ (Y\\ F) = Y\\ F\\).\nY F = \n(λx. F (x x))(λx. F (x x)) = \nF ((λx. F (x x))(λx. F (x x))) = \nF (Y X)\n\n\n\nY-комбинатор позволяет ввести рекурсию в λ-исчисление.\nНемного расширим ламбда-исчисление, чтобы показать как можно ввести рекурсивное определение факториала используя комбинатор неподвижной точки. Введем следующие функции\nPRED n — возвращает число предшествующее n\nMULT n m — возвращает произведение n и m\n\nISZRO n — возвращает true, если n является 0\nIIF (x, y, z) — функция сравнения, возвращает y, если x — true, иначе z\nТогда в этих определениях мы хотим написать определения факториала используя рекурсивный вызов.\nFAC = λn. IIF (ISZRO n) 1 (MULT n (FAC (PRED n)))\nНо в лямбда-исчислении нельзя использовать саморефенцию для определения термов. Мы должны уметь развернуть каждое наше обозначения до базовых термов.\nЧтобы решить эту проблему воспользуемся оператором неподвижной точки:\nПерепишем с помощью абстракции\nFAC = (λf λn. IIF (ISZRO n) 1 (MULT n (f (PRED n)))) FAC\nОбозначим (λf. λn. IIF (ISZRO n) 1 (MULT n (f (PRED n)))) как F\nFAC = F FAC\nВидно, что FAC — неподвижная точка функции F.\nТогда мы можем определить факториал следующим образом:\nFAC = Y F, где \nY — комбинатор неподвижной точки,\nF = λf. λn. IIF (ISZRO n) 1 (MULT n (f (PRED n)))\n\nРекурсия в λ-исчислении реализуется через понятие неподвижной точки, позволяющей определить функции, вызывающие сами себя. Ключевую роль играет Y-комбинатор, который создает неподвижную точку для любой функции.\nЭто позволяет разрабатывать рекурсивные алгоритмы в рамках λ-исчисления, избегая прямой самореференции.",
    "crumbs": [
      "Рекурсия"
    ]
  },
  {
    "objectID": "docs/fixed-point.html#самореплицируемая-функция",
    "href": "docs/fixed-point.html#самореплицируемая-функция",
    "title": "Рекурсия",
    "section": "",
    "text": "Рассмотрим следующую терм \\(\\omega = λx.x\\ x\\).\nw y = (λx.x x) y → y y\nПрименим его к самой себе:\nw w = (λx.x x) (λx.x x) →\n→ (λx.x x) (λx.x x) →\n...\nЭтот процесс будет повторятся бесконечно. Процесс вычисления никогда не завершится.\nЭтот оператор имеет философское отношение к парадоксу Рассела или парадоксу Клини, когда объект, определяемый через сам себя, приводит к некорректности или бесконечности.",
    "crumbs": [
      "Рекурсия"
    ]
  },
  {
    "objectID": "docs/fixed-point.html#теорема-неподвижной-точки",
    "href": "docs/fixed-point.html#теорема-неподвижной-точки",
    "title": "Рекурсия",
    "section": "",
    "text": "Для любого λ-терма F существует неподвижная точка\n\\[\n\\forall F\\ \\exists X: F\\ X = X\n\\]\n\n\nВведем - \\(W = λx. F (x x)\\) - \\(X = W W\\)\nТогда\nX = W W = (λx. F (x x)) W = F (W W) = F X",
    "crumbs": [
      "Рекурсия"
    ]
  },
  {
    "objectID": "docs/fixed-point.html#комбинатор-неподвижной-точки",
    "href": "docs/fixed-point.html#комбинатор-неподвижной-точки",
    "title": "Рекурсия",
    "section": "",
    "text": "Существует комбинатор неподвижной точки\nY = λf.(λx. f (x x))(λx. f (x x))\nтакой что \\(\\forall F:\\ F\\ (Y\\ F) = Y\\ F\\).\nY F = \n(λx. F (x x))(λx. F (x x)) = \nF ((λx. F (x x))(λx. F (x x))) = \nF (Y X)",
    "crumbs": [
      "Рекурсия"
    ]
  },
  {
    "objectID": "docs/fixed-point.html#рекурсия.-определение-факториала",
    "href": "docs/fixed-point.html#рекурсия.-определение-факториала",
    "title": "Рекурсия",
    "section": "",
    "text": "Y-комбинатор позволяет ввести рекурсию в λ-исчисление.\nНемного расширим ламбда-исчисление, чтобы показать как можно ввести рекурсивное определение факториала используя комбинатор неподвижной точки. Введем следующие функции\nPRED n — возвращает число предшествующее n\nMULT n m — возвращает произведение n и m\n\nISZRO n — возвращает true, если n является 0\nIIF (x, y, z) — функция сравнения, возвращает y, если x — true, иначе z\nТогда в этих определениях мы хотим написать определения факториала используя рекурсивный вызов.\nFAC = λn. IIF (ISZRO n) 1 (MULT n (FAC (PRED n)))\nНо в лямбда-исчислении нельзя использовать саморефенцию для определения термов. Мы должны уметь развернуть каждое наше обозначения до базовых термов.\nЧтобы решить эту проблему воспользуемся оператором неподвижной точки:\nПерепишем с помощью абстракции\nFAC = (λf λn. IIF (ISZRO n) 1 (MULT n (f (PRED n)))) FAC\nОбозначим (λf. λn. IIF (ISZRO n) 1 (MULT n (f (PRED n)))) как F\nFAC = F FAC\nВидно, что FAC — неподвижная точка функции F.\nТогда мы можем определить факториал следующим образом:\nFAC = Y F, где \nY — комбинатор неподвижной точки,\nF = λf. λn. IIF (ISZRO n) 1 (MULT n (f (PRED n)))\n\nРекурсия в λ-исчислении реализуется через понятие неподвижной точки, позволяющей определить функции, вызывающие сами себя. Ключевую роль играет Y-комбинатор, который создает неподвижную точку для любой функции.\nЭто позволяет разрабатывать рекурсивные алгоритмы в рамках λ-исчисления, избегая прямой самореференции.",
    "crumbs": [
      "Рекурсия"
    ]
  },
  {
    "objectID": "docs/type-theory/simple-type-theory.html",
    "href": "docs/type-theory/simple-type-theory.html",
    "title": "Просто типизированное лямбда-исчисление (Simple Type Theory)",
    "section": "",
    "text": "Является самой простой системой типизации лямбда-исчисления. Вводит только один тип для всех термов. В такой системе типизации каждый терм является либо атомом, либо абстракцией.\nМножество типом определяется следующим образом: 1. \\(\\alpha, \\beta, \\gamma, \\ldots \\in \\mathbb{T}\\) — типы переменных (атомов). 2. \\(\\sigma, \\tau \\in \\mathbb{T} \\Rightarrow (\\sigma \\rightarrow \\tau ) \\in \\mathbb{T}\\) — типы функций (абстракций).\nИли использую нотацию Бэкуса-Наура: \\[\n\\begin{array}{l}\n\\mathbb{T} ::= \\mathbb{V} \\mid \\ldots \\mid (\\sigma \\rightarrow \\tau) \\\\\n\\end{array}\n\\]\n\\(\\mathbb{V} ::= {\\alpha, \\beta, \\gamma, \\ldots}\\) — множество переменных (атомов).\n\nСоглашение о типизации: 1. \\(\\alpha, \\beta, \\gamma, \\ldots\\) — типы переменных (атомов). 2. \\(\\sigma, \\tau, \\ldots\\) — типы произвольных термов.\n\nСтрелка право ассоциативна, поэтому тип \\(\\sigma \\rightarrow \\tau \\rightarrow \\rho\\) можно записать как \\(\\sigma \\rightarrow (\\tau \\rightarrow \\rho)\\).\n\n\nЕсли терм переменная, то он может иметь любой тип: \\[\n\\begin{align}\n& x : \\alpha \\\\\n& y : \\alpha \\rightarrow \\beta \\\\\n& z : (\\alpha \\rightarrow \\beta) \\rightarrow \\gamma \\\\\n\\end{align}\n\\]\nЕсли терм аппликация \\(F\\ M\\), то типы термов должны совпадать:\n\n\\(F : \\sigma \\rightarrow \\tau\\) — функция, которая принимает аргумент типа \\(\\sigma\\) и возвращает значение типа \\(\\tau\\).\n\\(M : \\sigma\\) — аргумент функции.\n\\(F\\ M : \\tau\\) — аппликация, как результат применения функции к аргументу, должна иметь тип \\(\\tau\\).\n\nЕсли терм абстракция \\(\\lambda x^\\alpha . M\\), то тип терма должен быть функцией (стрелочным)\n\n\\(M : \\tau\\) — тело абстракции.\n\\(x : \\sigma\\) — тип аргумента.\n\\(\\lambda x. M : \\sigma \\rightarrow \\tau\\) — абстракция, как функция, должна иметь тип \\(\\sigma \\rightarrow \\tau\\).\n\n\n\n\\[\n\\begin{align}\n& x : \\alpha \\\\\n& \\lambda x. x : \\alpha \\rightarrow \\alpha \\\\\n\\end{align}\n\\]\nВопрос в том, что нужно ли указывать явно тип аргумента в абстракции? Здесь заключается разница в стилях типизации: стиле Карри и стиле Чёрча.\n\nНе указывать тип в абстракции. Тогда тип аргумента будет выводиться автоматически и может быть неоднозначным, допустимо несколько вариантов типов для одного терма.\n\n\\(\\lambda x. x : \\alpha → \\alpha\\)\n\\(\\lambda x. x : \\beta → \\beta\\)\n\\(\\lambda x. x : (\\alpha → \\beta) → (\\alpha → \\beta)\\)\n…\n\nУказывать тип аргумента явно. Тогда тип аргумента будет фиксированным и однозначным.\n\n\\(\\lambda x^\\alpha. x : \\alpha → \\alpha\\)1\n\n\n\n\n\n\nПредтермы — это термы, которые не являются корректными в простой типизации. Например, терм \\(\\lambda x. x\\ x\\) не может быть типизирован в простой типизации, так как он использует переменную \\(x\\) в разных контекстах.\n\n\n\nОбъявление типа терма в простой типизации выглядит следующим образом:\n\\[\n\\begin{align}\n& x : \\alpha \\\\\n& f : \\alpha → \\beta \\\\\n& g : (\\alpha → \\beta) → \\gamma \\\\\n\\end{align}\n\\]\n\n\n\nКонтекст — это множество объявлений типов для переменных. Контекст обозначается \\(\\Gamma\\) и может быть пустым или содержать объявления типов.\n\\[\n\\begin{align}\n& \\Gamma = \\{x : \\alpha, y : \\beta, z : \\gamma\\} \\\\\n\\end{align}\n\\]\nСкобки \\(\\{\\}\\) обозначающие множество, могут быть опущены. Тогда контекст будет выглядеть так:\n\\[\n\\begin{align}\n& \\Gamma = x : \\alpha, y : \\beta, z : \\gamma \\\\\n\\end{align}\n\\]\n\n\n\nНад контекстом можно выполнять операцию расширения, добавляя новые объявления типов.\n\\[\n\\begin{align}\n& \\Delta = \\Gamma, h : \\alpha → \\gamma = x : \\alpha, y : \\beta, z : \\gamma, h : \\alpha → \\gamma \\\\\n\\end{align}\n\\]\n\n\n\nутверждение \\(M : \\tau\\) (терм \\(M\\) имеет тип \\(\\tau\\)) в контексте \\(\\Gamma\\) называется выводимым, если существует последовательность правил вывода, которая приводит к этому утверждению.\n\\[\n\\begin{align}\n& \\Gamma \\vdash M : \\tau \\\\\n\\end{align}\n\\]\n\n\n\nПеременная в контексте (аксиома): \\(x : \\alpha \\in \\Gamma \\Rightarrow \\Gamma \\vdash x : \\alpha\\)\nАппликация (удаление →): если \\(\\Gamma \\vdash M : \\sigma \\rightarrow \\tau\\) и \\(\\Gamma \\vdash N : \\sigma\\), то \\(M\\Gamma \\vdash M\\ N : \\tau\\)\nАбстракция (введение →): если \\(\\Gamma, x : \\sigma \\vdash M : \\tau\\), то \\(\\Gamma \\vdash \\lambda x. M : \\sigma \\rightarrow \\tau\\)\n\nЕсли существует выводимость \\(M : \\tau\\) в контексте \\(\\Gamma\\), то терм \\(M\\) называется типизируемым (допустимым) в контексте \\(\\Gamma\\).\n\n\n\n\nПеременная в контексте (аксиома): \\(x : \\alpha \\in \\Gamma \\Rightarrow \\Gamma \\vdash x : \\alpha\\)\nАппликация (удаление →): если \\(\\Gamma \\vdash M : \\sigma \\rightarrow \\tau\\) и \\(\\Gamma \\vdash N : \\sigma\\), то \\(\\Gamma \\vdash M\\ N : \\tau\\)\nАбстракция (введение →): если \\(\\Gamma, x : \\sigma \\vdash M : \\tau\\), то \\(\\Gamma \\vdash \\lambda x^\\sigma. M : \\sigma \\rightarrow \\tau\\)",
    "crumbs": [
      "Системы типизации лямбда-исчисления",
      "Просто типизированное лямбда-исчисление (Simple Type Theory)"
    ]
  },
  {
    "objectID": "docs/type-theory/simple-type-theory.html#типизация-термов",
    "href": "docs/type-theory/simple-type-theory.html#типизация-термов",
    "title": "Просто типизированное лямбда-исчисление (Simple Type Theory)",
    "section": "",
    "text": "Если терм переменная, то он может иметь любой тип: \\[\n\\begin{align}\n& x : \\alpha \\\\\n& y : \\alpha \\rightarrow \\beta \\\\\n& z : (\\alpha \\rightarrow \\beta) \\rightarrow \\gamma \\\\\n\\end{align}\n\\]\nЕсли терм аппликация \\(F\\ M\\), то типы термов должны совпадать:\n\n\\(F : \\sigma \\rightarrow \\tau\\) — функция, которая принимает аргумент типа \\(\\sigma\\) и возвращает значение типа \\(\\tau\\).\n\\(M : \\sigma\\) — аргумент функции.\n\\(F\\ M : \\tau\\) — аппликация, как результат применения функции к аргументу, должна иметь тип \\(\\tau\\).\n\nЕсли терм абстракция \\(\\lambda x^\\alpha . M\\), то тип терма должен быть функцией (стрелочным)\n\n\\(M : \\tau\\) — тело абстракции.\n\\(x : \\sigma\\) — тип аргумента.\n\\(\\lambda x. M : \\sigma \\rightarrow \\tau\\) — абстракция, как функция, должна иметь тип \\(\\sigma \\rightarrow \\tau\\).\n\n\n\n\\[\n\\begin{align}\n& x : \\alpha \\\\\n& \\lambda x. x : \\alpha \\rightarrow \\alpha \\\\\n\\end{align}\n\\]\nВопрос в том, что нужно ли указывать явно тип аргумента в абстракции? Здесь заключается разница в стилях типизации: стиле Карри и стиле Чёрча.\n\nНе указывать тип в абстракции. Тогда тип аргумента будет выводиться автоматически и может быть неоднозначным, допустимо несколько вариантов типов для одного терма.\n\n\\(\\lambda x. x : \\alpha → \\alpha\\)\n\\(\\lambda x. x : \\beta → \\beta\\)\n\\(\\lambda x. x : (\\alpha → \\beta) → (\\alpha → \\beta)\\)\n…\n\nУказывать тип аргумента явно. Тогда тип аргумента будет фиксированным и однозначным.\n\n\\(\\lambda x^\\alpha. x : \\alpha → \\alpha\\)1",
    "crumbs": [
      "Системы типизации лямбда-исчисления",
      "Просто типизированное лямбда-исчисление (Simple Type Theory)"
    ]
  },
  {
    "objectID": "docs/type-theory/simple-type-theory.html#предтермы-псевдотермы",
    "href": "docs/type-theory/simple-type-theory.html#предтермы-псевдотермы",
    "title": "Просто типизированное лямбда-исчисление (Simple Type Theory)",
    "section": "",
    "text": "Предтермы — это термы, которые не являются корректными в простой типизации. Например, терм \\(\\lambda x. x\\ x\\) не может быть типизирован в простой типизации, так как он использует переменную \\(x\\) в разных контекстах.",
    "crumbs": [
      "Системы типизации лямбда-исчисления",
      "Просто типизированное лямбда-исчисление (Simple Type Theory)"
    ]
  },
  {
    "objectID": "docs/type-theory/simple-type-theory.html#объявление",
    "href": "docs/type-theory/simple-type-theory.html#объявление",
    "title": "Просто типизированное лямбда-исчисление (Simple Type Theory)",
    "section": "",
    "text": "Объявление типа терма в простой типизации выглядит следующим образом:\n\\[\n\\begin{align}\n& x : \\alpha \\\\\n& f : \\alpha → \\beta \\\\\n& g : (\\alpha → \\beta) → \\gamma \\\\\n\\end{align}\n\\]",
    "crumbs": [
      "Системы типизации лямбда-исчисления",
      "Просто типизированное лямбда-исчисление (Simple Type Theory)"
    ]
  },
  {
    "objectID": "docs/type-theory/simple-type-theory.html#контекст",
    "href": "docs/type-theory/simple-type-theory.html#контекст",
    "title": "Просто типизированное лямбда-исчисление (Simple Type Theory)",
    "section": "",
    "text": "Контекст — это множество объявлений типов для переменных. Контекст обозначается \\(\\Gamma\\) и может быть пустым или содержать объявления типов.\n\\[\n\\begin{align}\n& \\Gamma = \\{x : \\alpha, y : \\beta, z : \\gamma\\} \\\\\n\\end{align}\n\\]\nСкобки \\(\\{\\}\\) обозначающие множество, могут быть опущены. Тогда контекст будет выглядеть так:\n\\[\n\\begin{align}\n& \\Gamma = x : \\alpha, y : \\beta, z : \\gamma \\\\\n\\end{align}\n\\]",
    "crumbs": [
      "Системы типизации лямбда-исчисления",
      "Просто типизированное лямбда-исчисление (Simple Type Theory)"
    ]
  },
  {
    "objectID": "docs/type-theory/simple-type-theory.html#расширение-контекста",
    "href": "docs/type-theory/simple-type-theory.html#расширение-контекста",
    "title": "Просто типизированное лямбда-исчисление (Simple Type Theory)",
    "section": "",
    "text": "Над контекстом можно выполнять операцию расширения, добавляя новые объявления типов.\n\\[\n\\begin{align}\n& \\Delta = \\Gamma, h : \\alpha → \\gamma = x : \\alpha, y : \\beta, z : \\gamma, h : \\alpha → \\gamma \\\\\n\\end{align}\n\\]",
    "crumbs": [
      "Системы типизации лямбда-исчисления",
      "Просто типизированное лямбда-исчисление (Simple Type Theory)"
    ]
  },
  {
    "objectID": "docs/type-theory/simple-type-theory.html#типизация-терма",
    "href": "docs/type-theory/simple-type-theory.html#типизация-терма",
    "title": "Просто типизированное лямбда-исчисление (Simple Type Theory)",
    "section": "",
    "text": "утверждение \\(M : \\tau\\) (терм \\(M\\) имеет тип \\(\\tau\\)) в контексте \\(\\Gamma\\) называется выводимым, если существует последовательность правил вывода, которая приводит к этому утверждению.\n\\[\n\\begin{align}\n& \\Gamma \\vdash M : \\tau \\\\\n\\end{align}\n\\]\n\n\n\nПеременная в контексте (аксиома): \\(x : \\alpha \\in \\Gamma \\Rightarrow \\Gamma \\vdash x : \\alpha\\)\nАппликация (удаление →): если \\(\\Gamma \\vdash M : \\sigma \\rightarrow \\tau\\) и \\(\\Gamma \\vdash N : \\sigma\\), то \\(M\\Gamma \\vdash M\\ N : \\tau\\)\nАбстракция (введение →): если \\(\\Gamma, x : \\sigma \\vdash M : \\tau\\), то \\(\\Gamma \\vdash \\lambda x. M : \\sigma \\rightarrow \\tau\\)\n\nЕсли существует выводимость \\(M : \\tau\\) в контексте \\(\\Gamma\\), то терм \\(M\\) называется типизируемым (допустимым) в контексте \\(\\Gamma\\).\n\n\n\n\nПеременная в контексте (аксиома): \\(x : \\alpha \\in \\Gamma \\Rightarrow \\Gamma \\vdash x : \\alpha\\)\nАппликация (удаление →): если \\(\\Gamma \\vdash M : \\sigma \\rightarrow \\tau\\) и \\(\\Gamma \\vdash N : \\sigma\\), то \\(\\Gamma \\vdash M\\ N : \\tau\\)\nАбстракция (введение →): если \\(\\Gamma, x : \\sigma \\vdash M : \\tau\\), то \\(\\Gamma \\vdash \\lambda x^\\sigma. M : \\sigma \\rightarrow \\tau\\)",
    "crumbs": [
      "Системы типизации лямбда-исчисления",
      "Просто типизированное лямбда-исчисление (Simple Type Theory)"
    ]
  },
  {
    "objectID": "docs/type-theory/simple-type-theory.html#footnotes",
    "href": "docs/type-theory/simple-type-theory.html#footnotes",
    "title": "Просто типизированное лямбда-исчисление (Simple Type Theory)",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nМы часто будем писать \\(\\lambda x^\\alpha. M\\) вместо \\(\\lambda x : \\alpha. M\\), указывая тип аргумента вверху для просты чтения↩︎",
    "crumbs": [
      "Системы типизации лямбда-исчисления",
      "Просто типизированное лямбда-исчисление (Simple Type Theory)"
    ]
  },
  {
    "objectID": "docs/Lambda_vs_Turing.html",
    "href": "docs/Lambda_vs_Turing.html",
    "title": "λ-исчисление",
    "section": "",
    "text": "По сути, они обе полны по Тьюрингу, одно можно заменить другим.\nРазница представлена в виде таблицы:\n\n\n\n\n\n\n\n\nКритерий\nLambda\nTuring\n\n\n\n\nМодель\nАбстрактная математическая модель, основанная на функциях и их применении.\nАбстрактный автомат с лентой и таблицей переходов.\n\n\nФорма\nВычисления задаются через функциональные преобразования и рекурсию.\nОперации определяются через пошаговые модификации ленты и состояния.\n\n\nДекларативность\nБольше ориентировано на выражение функций.\nИнструкции описывают шаги выполнения.\n\n\nАбстракция\nВысокий уровень абстракции. Математическая чистота.\nБолее низкий уровень, приближённый к реальному исполнению на машине.\n\n\nВыражение алгоритмов\nКомпозиция функций.\nСостояния и пошаговое изменение ленты.\n\n\nЧитаемость\nБолее сложное для восприятия новичками из-за чисто функционального подхода.\nБолее наглядное для имитации конкретного вычислительного процесса.",
    "crumbs": [
      "Различия между Lambda и Turing"
    ]
  },
  {
    "objectID": "docs/Lambda_vs_Turing.html#различия-между-lambda-и-turing",
    "href": "docs/Lambda_vs_Turing.html#различия-между-lambda-и-turing",
    "title": "λ-исчисление",
    "section": "",
    "text": "По сути, они обе полны по Тьюрингу, одно можно заменить другим.\nРазница представлена в виде таблицы:\n\n\n\n\n\n\n\n\nКритерий\nLambda\nTuring\n\n\n\n\nМодель\nАбстрактная математическая модель, основанная на функциях и их применении.\nАбстрактный автомат с лентой и таблицей переходов.\n\n\nФорма\nВычисления задаются через функциональные преобразования и рекурсию.\nОперации определяются через пошаговые модификации ленты и состояния.\n\n\nДекларативность\nБольше ориентировано на выражение функций.\nИнструкции описывают шаги выполнения.\n\n\nАбстракция\nВысокий уровень абстракции. Математическая чистота.\nБолее низкий уровень, приближённый к реальному исполнению на машине.\n\n\nВыражение алгоритмов\nКомпозиция функций.\nСостояния и пошаговое изменение ленты.\n\n\nЧитаемость\nБолее сложное для восприятия новичками из-за чисто функционального подхода.\nБолее наглядное для имитации конкретного вычислительного процесса.",
    "crumbs": [
      "Различия между Lambda и Turing"
    ]
  },
  {
    "objectID": "docs/Lambda_vs_Turing.html#плюсы-и-минусы",
    "href": "docs/Lambda_vs_Turing.html#плюсы-и-минусы",
    "title": "λ-исчисление",
    "section": "Плюсы и минусы",
    "text": "Плюсы и минусы\n\nLabmda\nПлюсы: - Высокий уровень абстракции: позволяет описывать вычисления чисто математически. - Функциональный стиль: компактное и декларативное представление программ. - Математическая чистота: формальные доказательства корректности функций проще проводить. - Близость к современным языкам программирования: многие языки (например, Haskell, Lisp) используют идеи лямбда-исчисления.\nМинусы: - Трудности интерпретации: выполнение требует преобразования функций, что сложно для понимания. - Ограниченность моделирования состояния: отсутствие “пошагового” изменения состояния, как в императивных моделях. - Сложность реализации: для реального железа необходимо трансформировать выражения в машинные инструкции.\n\n\nTuring\nПлюсы: - Наглядность и интуитивность: легко представить вычисление как последовательность шагов. - Приближенность к аппаратному исполнению: модели состояния близки к работе процессоров. - Гибкость моделирования: можно выразить любые алгоритмы с дискретным изменением памяти. - Основа императивного программирования: родоначальник современных языков и архитектуры компьютеров.\nМинусы: - Низкий уровень абстракции: описания вычислений могут быть громоздкими. - Медлительность: моделирование сложных алгоритмов требует большого количества шагов. - Неудобство для функционального стиля: для чисто математических выражений менее эффективен.",
    "crumbs": [
      "Различия между Lambda и Turing"
    ]
  },
  {
    "objectID": "docs/Lambda_vs_Turing.html#что-лучше-делать-на-каждом",
    "href": "docs/Lambda_vs_Turing.html#что-лучше-делать-на-каждом",
    "title": "λ-исчисление",
    "section": "Что лучше делать на каждом?",
    "text": "Что лучше делать на каждом?\n\nLambda\n\nФункциональное программирование: когда нужно выразить вычисления через композицию функций (например, рекурсивные алгоритмы).\nДоказательства корректности алгоритмов: благодаря чисто математическому подходу.\nРазработка теоретических моделей вычислений: например, исследование вычислимости функций или формального анализа программ.\nКомбинаторные вычисления: системы, использующие функции высшего порядка.\n\n\n\nTuring\n\nМоделирование пошаговых вычислений: например, алгоритмы работы памяти или устройства.\nИмперативные алгоритмы: программы, работающие со состоянием и изменяющие память (циклы, присваивания).\nСоздание симуляторов реального оборудования: имитация работы процессоров, интерпретаторов.\nТеоретические исследования конечных автоматов и их расширений.",
    "crumbs": [
      "Различия между Lambda и Turing"
    ]
  },
  {
    "objectID": "docs/Lambda_vs_Turing.html#пример-алгоритма-сложения",
    "href": "docs/Lambda_vs_Turing.html#пример-алгоритма-сложения",
    "title": "λ-исчисление",
    "section": "Пример алгоритма сложения",
    "text": "Пример алгоритма сложения\n\nlambda\nadd = λm.λn.λf.λx. m f (n f x)\n\nadd 2 3\n= (λm.λn.λf.λx. m f (n f x)) 2 3\n\nadd 2 3 = λf.λx. (λf.λx.f (f x)) f ((λf.λx.f (f (f x))) f x)\n\n\nTuring\nq0 1 &gt; q0 1 R\nq0 # &gt; q1 # R\nq1 1 &gt; q2 E L\nq 2 1 &gt; q2 1 L\nq2 # &gt; q0 # R\nq0 E &gt; qf E Stop\n\n111#11 &gt; 11111",
    "crumbs": [
      "Различия между Lambda и Turing"
    ]
  },
  {
    "objectID": "presentation/presentation.html#история-появления",
    "href": "presentation/presentation.html#история-появления",
    "title": "λ-исчисление",
    "section": "История появления",
    "text": "История появления\n\nФреге 1893\n\n\\[A + B = (\\oplus(A))(B)\\]\n\nРассел 1910. Теория типов\nШейнфинкель 1924\nЧёрчь 1932\n\n\\[\nλx.M\n\\]",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#зачем-придумана-теория-типов",
    "href": "presentation/presentation.html#зачем-придумана-теория-типов",
    "title": "λ-исчисление",
    "section": "Зачем придумана теория типов",
    "text": "Зачем придумана теория типов\n\nВ наивной теории множеств существует парадокс Рассела\nТипы создают иерархию объектов, исключая самоссылку\nОграничение допустимых формул",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#определение-λ-исчисления.-термы",
    "href": "presentation/presentation.html#определение-λ-исчисления.-термы",
    "title": "λ-исчисление",
    "section": "Определение λ-исчисления. Термы",
    "text": "Определение λ-исчисления. Термы\nt ::=\n    x  # переменная (variable)\n    | λx.t  # абстракция (lambda abstraction)\n    | t t  # применение (application)\n\nСоглашения\n\nЛево-ассоциативность применения:\n\nt1 t2 t3 = (t1 t2) t3\n\nТело абстракции идёт до конца выражения:\n\nλx. x y = λx. (x y)\n\nλx.λy.x y = λx.(λy.(x y))\n\nλx.λy.x y z = λx.(λy.((x y) z))",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#примеры",
    "href": "presentation/presentation.html#примеры",
    "title": "λ-исчисление",
    "section": "Примеры",
    "text": "Примеры\n\n\nКомбинатор тождества\n\n(λx.x) y \n→ x[x := y] \n= y\n\n\n\nПрименение комбинатора тождества к комбинатору тождества\n\n(λx.x) (λx.x) → \nx[x := (λx.x)] \n= λx.x\n\n\n\nЛево-ассоциативность\n\n(λx.x) (λx.x) y \n→ x[x := (λx.x)] y \n= λx.x y",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#формализация.-beta-редукция",
    "href": "presentation/presentation.html#формализация.-beta-редукция",
    "title": "λ-исчисление",
    "section": "Формализация. \\(\\beta\\)-редукция",
    "text": "Формализация. \\(\\beta\\)-редукция\n(λx.t) u → t[x := u]\nЗаменяем в терме \\(t\\) вхождения \\(x\\) на \\(u\\) и убираем λ, то есть редуцируем.\n\n\\(\\beta\\)-редукция — вычисление в λ-исчислении",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#true-false-if",
    "href": "presentation/presentation.html#true-false-if",
    "title": "λ-исчисление",
    "section": "true, false, if",
    "text": "true, false, if\nВведем константы\ntru = λt. λf. t # возвращает первый аргумент\nfls = λt. λf. f # возвращает второй аргумент\nВведем функцию test — аналог if-else\ntest = λl. λm. λn. l m n\n\nПример\ntest tru v w = \n= (λl. λm. λn. l m n) tru v w →\n→ (λm. λn. tru m n) v w →\n→ (λn. tru v n) w →\n→ tru v w =\n= (λt. λf. t) v w →\n→ (λf. v) w →\n→ v",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#бесконечная-саморедукция",
    "href": "presentation/presentation.html#бесконечная-саморедукция",
    "title": "λ-исчисление",
    "section": "Бесконечная саморедукция",
    "text": "Бесконечная саморедукция\nРассмотрим следующую функцию \\(\\omega = λx.x\\ x\\). Применим её к самой себе:\nw y = (λx.x x) y → y y\n\nw w = (λx.x x) (λx.x x) →\n→ (λx.x x) (λx.x x) →\n...",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#подстановка",
    "href": "presentation/presentation.html#подстановка",
    "title": "λ-исчисление",
    "section": "Подстановка",
    "text": "Подстановка\nx[x := u] = u\ny[x := u] = y\n(λy.t)[x := u] = λy.t[x := u]\n(t1 t2)[x := u] = t1[x := u] t2[x := u]\n\nλ связывает переменные\n(λx.x)[x := u] != λx.u  # x связан\n(λx.x)[x := u] = λx.x   # подстановка должна заканчиваться на связанной переменной\n\n\nНО\n(λx.y)[y := x] = λx.x # y свободен — x при подстановке должен остаться не связанным,\n# но в результате подстановки мы получили\n# связанную переменную — захватили свободную переменную",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#решение.-alpha-конверсия",
    "href": "presentation/presentation.html#решение.-alpha-конверсия",
    "title": "λ-исчисление",
    "section": "Решение. \\(\\alpha\\)-конверсия",
    "text": "Решение. \\(\\alpha\\)-конверсия\n(λx.s) = (λy.s[x := y])",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#сравнение-с-языками-программирования",
    "href": "presentation/presentation.html#сравнение-с-языками-программирования",
    "title": "λ-исчисление",
    "section": "Сравнение с языками программирования",
    "text": "Сравнение с языками программирования\nλ-исчисление\nλx.λy.(x + y)\nPython\nadd = lambda x: lambda y: x + y\nJS\nconst add = x =&gt; y =&gt; x + y;\nHaskell\nadd :: Int -&gt; Int -&gt; Int\nadd x y = x + y\n-- или\nadd = \\x -&gt; \\y -&gt; x + y",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#типы",
    "href": "presentation/presentation.html#типы",
    "title": "λ-исчисление",
    "section": "Типы",
    "text": "Типы\nВведем множество типов переменных \\(\\mathcal{X}\\). И населим его одним базовым типом \\(\\circ\\)\n\\[\\mathcal{X} = \\{\\circ\\}\\]\n\\[\n\\begin{align}\n& x^\\circ \\\\\n& y^\\circ \\\\\n\\\\\n& f = λx^\\circ .y^\\circ \\\\\n& f^{\\circ→\\circ}\n\\end{align}\n\\]",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#типы.-bool-и-nat",
    "href": "presentation/presentation.html#типы.-bool-и-nat",
    "title": "λ-исчисление",
    "section": "Типы. Bool и Nat",
    "text": "Типы. Bool и Nat\n\\[\n\\begin{align}\n& true = λt^\\circ. λf^\\circ. t \\\\\n& false = λt^\\circ. λf^\\circ. f \\\\\n& Bool = \\circ → \\circ → \\circ\\ \\\\\n\\\\\n& zero = λs^{\\circ→\\circ}. λz^\\circ. z\\\\\n& succ = λn. λs. λz^\\circ. s\\ n\\ s\\ z \\\\\n& one = succ\\ zero = λs. λz^\\circ. s\\ z\\\\\n& ... \\\\\n& Nat = (\\circ → \\circ) → \\circ → \\circ\n\\end{align}\n\\]",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#типизация-по-черчу",
    "href": "presentation/presentation.html#типизация-по-черчу",
    "title": "λ-исчисление",
    "section": "Типизация по Черчу",
    "text": "Типизация по Черчу\n\nКаждая константа имеет свой тип\nВ каждом типе есть свой счетный набор переменных\n\n\n\\[\n\\begin{align}\n& u:\\beta  \\text{ переменная } u \\text{ имеет жестко заданный тип } \\beta \\\\\n\\end{align}\n\\]\n\n\n\\[\n\\begin{align}\n& u:\\beta \\implies (λx^\\sigma.u) : (\\sigma → \\beta) \\\\\n\\end{align}\n\\]\n\n\n\\[\n\\begin{align}\n& u:(\\alpha → \\beta),\\ v:\\alpha  \\implies u\\ v : \\beta\n\\end{align}\n\\]",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#типизация-по-карри",
    "href": "presentation/presentation.html#типизация-по-карри",
    "title": "λ-исчисление",
    "section": "Типизация по Карри",
    "text": "Типизация по Карри\n\nТермы остаются такие же как и в бестиповом\nВводится отношение типизируемости\nДля свободных переменных типы задаются явно\nОстальные типы выводятся",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#типизация-по-карри-1",
    "href": "presentation/presentation.html#типизация-по-карри-1",
    "title": "λ-исчисление",
    "section": "Типизация по Карри",
    "text": "Типизация по Карри\n\\(\\Gamma \\vdash u:b\\)\nЕсли из контекста имеется вывод, что \\(u:b\\) тогда \\(u\\) может иметь тип \\(b\\)\n\n\\(\\Gamma, x:\\alpha \\vdash x : \\alpha\\)\n\n\n\\(\\Gamma \\vdash u: (\\alpha → \\beta),\\ \\Gamma \\vdash v : \\alpha \\implies \\Gamma \\vdash (uv) : \\beta\\)\n\n\n\\(\\Gamma, x : \\alpha \\vdash u : \\beta \\implies \\Gamma \\vdash (λx. u) : (\\alpha → \\beta)\\)",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#коротко",
    "href": "presentation/presentation.html#коротко",
    "title": "λ-исчисление",
    "section": "Коротко",
    "text": "Коротко\nТипизация по Черчу\n\nПереопределяются термы\nВсё имеет заданный жесткий тип\n\nТипизация по Карри\n\nТермы такие же как в бестиповом\nТипы выводятся\nДля некоторых термов может не существовать типа",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#выгода-типизации",
    "href": "presentation/presentation.html#выгода-типизации",
    "title": "λ-исчисление",
    "section": "Выгода типизации",
    "text": "Выгода типизации\n\nЗапрет конструкций (λx.x x) (λx.x x), т.к. она не имеет типа.\nСтатический контроль. \\(\\beta\\)-редукция сохраняет тип выражения\n\n\nλx.x x — не имеет типа",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#тьюринг-vs-lambda",
    "href": "presentation/presentation.html#тьюринг-vs-lambda",
    "title": "λ-исчисление",
    "section": "Тьюринг vs Lambda",
    "text": "Тьюринг vs Lambda\nλ-исчисление\n\nОриентирован на математические функции\nКомпозиция функций\nВысокая абстракция\n\nМашина Тьюринга\n\nАвтомат с лентой таблицей переходов\nДискретные состояния и пошаговое изменение ленты\nЯвное представление",
    "crumbs": [
      "Презентация"
    ]
  },
  {
    "objectID": "presentation/presentation.html#сложение-чисел",
    "href": "presentation/presentation.html#сложение-чисел",
    "title": "λ-исчисление",
    "section": "Сложение чисел",
    "text": "Сложение чисел\nλ-исчисление\n2 = λs λz s (s z)\n3 = λs λz s (s (s z))\nadd = λm. λn. λs. λz. m s (n s z)\n\nadd 2 3\nМашина Тьюринга\nq0 1 → q0 1 R\nq0 # → q0 # R\nq1 1 → q2 ε L\nq2 1 → q2 1 L\nq2 # → q0 1 R\nq0 ε → q0 ε N\n\n111#11 &gt; 11111",
    "crumbs": [
      "Презентация"
    ]
  }
]